

<!DOCTYPE html>   
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>テンプレ</title>

<!-- ：ポップなフォント（演出用） -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@700;800&family=Fredoka:wght@600;700&display=swap" rel="stylesheet">

<style>
  /* =========================
     ★スクロール完全停止（サイト全体）
     ========================= */
  html, body{
    height:100%;
    overflow:hidden;
    overscroll-behavior:none;   /* バウンス抑止 */
  }
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    background:#fff;
    color:#111;
    touch-action:none;          /* bodyレベルでスクロール/パンを抑止 */
  }

  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative;} /* ★変更：局所レイヤーは個別に管理 */
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* ★変更：mainのスクロール停止 */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:hidden;            /* ★スクロール禁止 */
    overscroll-behavior:none;   /* ★引っ張り/バウンス抑止 */
    touch-action:none;          /* ★指スクロール抑止 */
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  /* ★操作したい要素だけ、タップ操作を許可（スクロールは許可しない） */
  button, input, .btn,
  .player-wrap, .player-tag,
  .deck-stack, .board-row, .board-slot,
  .chip-pool, .chip-pool-area,
  .side-cards, .side-card,
  .help-pop, .help-pop-body, .help-pop-header,
  .seat-pop, .tab,
  .dialog-box{
    touch-action: manipulation;
  }

  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  .player-circle{
    position:relative;
    width:320px;
    height:320px;
    margin:20px auto 0;border-radius:50%;
    box-sizing:border-box;
    border:3px solid #000;
    z-index:210; /* ★変更：チッププールより前に */
    pointer-events:none;
  }
  .player-circle::before{content:'';}

  /* =========================
     ：スペシャル5中「円の中＝捨てる場所」を表示
     ========================= */
  .player-circle.discard-active::after{
    content:'捨てる';
    position:absolute;
    inset:14px;
    border-radius:50%;
    border:2px dashed rgba(0,0,0,.55);
    background:rgba(255,255,255,.10);
    display:grid;
    place-items:center;
    font-weight:900;
    font-size:18px;
    color:rgba(0,0,0,.55);
    pointer-events:none;
  }


  .player-wrap{
    position:absolute;
    transform:translate(-50%,-50%);
    display:flex;
    align-items:center;
    gap:6px;
    z-index:211; /* ★変更 */
    pointer-events:auto;
  }

  .player-tag{
    position:relative;
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    z-index:212;
    pointer-events:auto;
  }
  .player-wrap.top-seat .player-tag{
    transform:translateY(70px);
  }
.player-wrap.top-seat .owned-chips{
  transform:translateY(70px);
}


  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  /* ：公開ターンの強調（現在の番） */
  .player-tag.turn{
    outline:2px solid #16a34a;
    outline-offset:2px;
  }
  .player-tag.me.turn{
    cursor:pointer;
  }
  .player-tag.me.turn::after{
    content:'公開';
    margin-left:6px;
    font-size:10px;
    font-weight:900;
    padding:1px 6px;
    border-radius:999px;
    background:rgba(22,163,74,.18);
    color:#eafff2;
    border:1px solid rgba(22,163,74,.35);
  }

  .owncircle{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:var(--oc-w, 44px);
    height:var(--oc-h, 44px);
    border-radius:999px;
    border:2px solid #000;
    pointer-events:none;
    z-index:-1;
  }
  .owncircle.hidden{ display:none; }

  .player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:60px;height:30px;pointer-events:none;
    z-index:500; /* ：プールより上 */
  }
  .player-tag .mini-card{
    position:absolute;left:50%;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background:linear-gradient(135deg,#e5e7eb,#cbd5f5);
    font-size:10px;display:flex;align-items:center;justify-content:center;
    transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }

  /* ：公開手札（まっすぐ横一列） */
  .player-tag .reveal-hand{
    position:absolute;
    left:50%;
    top:100%;
    transform:translate(-50%,6px);
    display:flex;
    gap:4px;
    pointer-events:none;
    z-index:500; /* ：プールより上 */
  }
  .reveal-card{
    width:34px;
    height:52px;
  }
  .reveal-card .pcard,
  .reveal-card .backcard{
    width:100% !important;
    height:100% !important;
    border-radius:6px !important;
  }
  .reveal-card .pcard .corner .rank{ font-size:7px !important; }
  .reveal-card .pcard .corner .suit{ font-size:7px !important; }
  .reveal-card .pcard .pip{ font-size:9px !important; }
  .reveal-card .pcard[data-rank="A"] .pip{ font-size:18px !important; }
  .reveal-card .pcard .face-holder{ font-size:16px !important; }
  .reveal-card .pcard .face-suit{ font-size:13px !important; }

  :root{ --chip-d: 24px; }
  .owned-chips{
    display:flex;
    align-items:center;
    gap:4px;
    min-height:var(--chip-d);
    position:relative;
    z-index:212;
    pointer-events:auto;
  }

  .owned-chip{
    width:var(--chip-d);
    height:var(--chip-d);
    border-radius:999px;
    overflow:hidden;
  }
  .owned-chip svg{ width:100%; height:100%; display:block; }

  /* =========================
     ：スペシャル1用 他プレイヤー ownarea（ドロップ先）
     - サイズは自分のownchipと同等（--chip-d）
     ========================= */
  /* =========================
     ★修正：スペシャル1用 他プレイヤー ownarea（ドロップ先）
     - ネームタグ(.player-tag)を囲む「枠」にする
     - player-wrap 内で absolute にしてタグに被せる
     ========================= */
  .other-ownarea{
    position:absolute;
    /* tag を囲むように上下左右に余白を取る */
    left:-6px;
    right:-6px;
    top:-6px;
    bottom:-6px;

    border-radius:999px;
    border:2px dashed rgba(0,0,0,.75);
    background:rgba(255,255,255,.10);
    box-shadow:0 6px 16px rgba(0,0,0,.12);

    /* 見た目の矢印などは不要なので非表示 */
    display:block;

    user-select:none;
    pointer-events:none; /* 当たり判定はJSでrectを見る */
    opacity:.35;
    transform:translateY(0);

    /* player-tag の背面に置く（tagのz-index:212より小さく） */
    z-index:211;
  }


  /* スペシャル1中だけ分かりやすく光らせる */
  .player-circle.special1-active .other-ownarea{
    opacity:1;
    outline:2px solid rgba(22,163,74,.9);
    outline-offset:2px;
    animation: ownAreaPulse .85s cubic-bezier(.22,.84,.44,1) infinite;
  }
  @keyframes ownAreaPulse{
    0%   { transform:translateY(0) scale(1); }
    50%  { transform:translateY(-1px) scale(1.08); }
    100% { transform:translateY(0) scale(1); }
  }
/* ★追加：12時席だけネームタグが70px下がっているので、囲み枠も同じだけ下げる */
.player-wrap.top-seat .other-ownarea{
  transform: translateY(70px);
}

/* ★追加：12時席は70px下げたままパルスさせる（transformが上書きされないように） */
.player-circle.special1-active .player-wrap.top-seat .other-ownarea{
  animation: ownAreaPulseTop .85s cubic-bezier(.22,.84,.44,1) infinite;
}

@keyframes ownAreaPulseTop{
  0%   { transform:translateY(70px) scale(1); }
  50%  { transform:translateY(69px) scale(1.08); } /* -1pxだけ浮かせる */
  100% { transform:translateY(70px) scale(1); }
}


  .owned-chip.draggable{ cursor:grab; }
  .owned-chip.draggable:active{ cursor:grabbing; }

  .my-hand-wrapper{margin-top:16px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand{display:flex;justify-content:center;gap:8px;margin-top:6px;min-height:100px;}

 /* =========================
     ：スペシャル1/5 手札の大小アニメ & ドラッグ状態
     ========================= */
  .my-hand.special-pulse > *{
    animation: handPulse .85s cubic-bezier(.22,.84,.44,1) infinite;
    transform-origin:center;
  }
  .my-hand.special6-pulse .pcard,
  .my-hand.special6-pulse .backcard{
    animation: special6Pulse .8s ease-in-out infinite;
    transform-origin:center;
  }
  @keyframes handPulse{
    0%   { transform:translateY(0)   scale(1); }
    50%  { transform:translateY(-2px) scale(1.06); }
    100% { transform:translateY(0)   scale(1); }
  }
  @keyframes special6Pulse{
    0%{ transform:scale(1); }
    50%{ transform:scale(1.08); }
    100%{ transform:scale(1); }
  }
  .my-hand.special-dragging .pcard,
  .my-hand.special-dragging .backcard{
    cursor:grab;
    touch-action:none;
  }
  .my-hand.special-dragging .pcard:active,
  .my-hand.special-dragging .backcard:active{
    cursor:grabbing;
  }

  /* =========================
     ：相手画面中央に3秒表示（カード＋プレイヤー名）
     ========================= */
  .special-card-show{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    z-index:2147483647;
    pointer-events:none;
  }
  .special-card-show.hidden{ display:none; }
  .special-card-panel{
    position:relative;
    padding:14px 16px 12px;
    border-radius:18px;
    background:rgba(20,20,20,.92);
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    transform:translateY(6px) scale(.98);
    opacity:0;
    animation:specialShowIn .18s cubic-bezier(.22,.84,.44,1) forwards;
  }
  @keyframes specialShowIn{
    to{ transform:translateY(0) scale(1); opacity:1; }
  }
  .special-card-name{
    font-family:'Fredoka','Baloo 2',system-ui,sans-serif;
    font-weight:800;
    color:#fff;
    text-align:center;
    margin:0 0 10px;
    letter-spacing:.02em;
    font-size:16px;
    white-space:nowrap;
  }
  .special-card-slot{
    display:flex; justify-content:center;
  }
  .special-card-slot .pcard,
  .special-card-slot .backcard{
    width:120px !important;
    height:180px !important;
    border-radius:14px !important;
    box-shadow:0 18px 44px rgba(0,0,0,.45) !important;
    border-color:rgba(255,255,255,.25) !important;
  }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
  .role-row{display:flex;gap:12px;align-items:flex-start;padding:10px 0;}
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;display:flex;align-items:center;justify-content:center;
    font-size:12px;font-weight:700;color:#444;
  }
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  .center-table{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    display:flex; align-items:center; gap:10px;
    pointer-events:none;
  }

  .deck-stack{
    width:54px;height:78px;
    position:relative;
    border-radius:10px;
    pointer-events:auto;
    cursor:pointer;
  }
  .deck-stack.empty{
    outline:1px dashed rgba(255,255,255,.45);
    outline-offset:-4px;
    background:rgba(20,20,20,.22);
    box-shadow:none;
  }
  .deck-layer{
    position:absolute; inset:0;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.65);
    box-shadow:none;
    overflow:hidden;
    background:
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
      repeating-linear-gradient(45deg, rgba(255,255,255,.10) 0 2px, rgba(255,255,255,0) 2px 6px),
      linear-gradient(135deg, rgba(185,28,28,.95), rgba(127,29,29,.95));
  }
  .deck-layer::after{
    content:'';
    position:absolute; inset:6px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.45);
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.15);
  }
  .deck-count{
    position:absolute; right:-6px; top:-8px;
    min-width:22px;height:18px;padding:0 6px;
    display:flex;align-items:center;justify-content:center;
    border-radius:999px;
    background:rgba(0,0,0,.55);
    color:#fff;font-size:11px;font-weight:900;
    text-shadow:none;
    border:1px solid rgba(255,255,255,.25);
    pointer-events:none;
  }

  .board-row{ display:flex; gap:8px; pointer-events:auto; }

  .board-slot{
    width:48px;height:72px;
    border-radius:10px;
    border:none;
    background:transparent;
    box-shadow:none;
    backdrop-filter:none;
    display:flex;align-items:center;justify-content:center;
    position:relative;
    overflow:visible;
    pointer-events:auto;
  }
  .board-slot.has-card{ cursor:pointer; }

  .pcard{
    width:60px;height:90px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    box-shadow:0 4px 12px rgba(0,0,0,.15);
    position:relative;
    overflow:hidden;
    user-select:none;
  }
  .pcard.red{ color:#c1121f; }
  .pcard.black{ color:#111; }

  .pcard .corner{
    position:absolute;
    display:flex;flex-direction:column;align-items:center;
    font-weight:900;
    line-height:1;
    gap:0px;
z-index: 10; 
  }
  .pcard .corner .rank{ font-size:10px; }
  .pcard .corner .suit{ font-size:10px; transform:translateY(-1px); }
  .pcard .corner.tl{ left:3px; top:3px; }
  .pcard .corner.br{ right:3px; bottom:3px; transform:rotate(180deg); }

  .pcard .pips{
    position:absolute;
    left:10px; right:10px;
    top:16px; bottom:16px;
  }
  .pcard .pip{
    position:absolute;
    transform:translate(-50%,-50%);
    font-weight:900;
    font-size:12px;
  }
  .pcard .pip.flip{ transform:translate(-50%,-50%) rotate(180deg); }
  .pcard[data-rank="A"] .pip{ font-size:26px !important; }

  .pcard .face-holder{
    position:absolute; inset:14px 10px;
    border-radius:8px;
    display:flex;align-items:center;justify-content:center;
    font-weight:1000;
    font-size:28px;
    opacity:.20;
    letter-spacing:.02em;
  }
  .pcard .face-suit{
    position:absolute;
    left:50%; top:52%;
    transform:translate(-50%,-50%);
    font-size:22px;
    opacity:.35;
    font-weight:900;
  }

  .my-card{ width:60px;height:90px; }

  .backcard{
    width:60px;height:90px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.65);
    overflow:hidden;
    position:relative;
    background:
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
      repeating-linear-gradient(45deg, rgba(255,255,255,.10) 0 2px, rgba(255,255,255,0) 2px 6px),
      linear-gradient(135deg, rgba(185,28,28,.95), rgba(127,29,29,.95));
    box-shadow:0 4px 12px rgba(0,0,0,.15);
  }
  .backcard::after{
    content:'';
    position:absolute;
    inset:6px;
    border-radius:6px;
    border:1px solid rgba(255,255,255,.45);
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.15);
  }

  .board-slot .pcard,
  .board-slot .backcard{
    width:48px !important;
    height:72px !important;
  }

  .fly-card{
    position:fixed;
    width:60px;height:90px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.65);
    overflow:hidden;
    z-index:9999;
    pointer-events:none;
    background:
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
      repeating-linear-gradient(45deg, rgba(255,255,255,.10) 0 2px, rgba(255,255,255,0) 2px 6px),
      linear-gradient(135deg, rgba(185,28,28,.95), rgba(127,29,29,.95));
  }
  .fly-card::after{
    content:'';
    position:absolute; inset:6px;
    border-radius:6px;
    border:1px solid rgba(255,255,255,.45);
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.15);
  }

  /* =========================
     ：左上のマネー/サイレンカード
     ========================= */
  .side-cards{
    position:fixed;
    left:12px;
    top:68px;
    z-index:205;
    display:flex;
    flex-direction:column;
    gap:8px;
    pointer-events:auto;
  }
  .side-cards.hidden{ display:none; }
  .side-row{ display:flex; gap:8px; }
  .side-card{
    width:72px;
    height:48px;
    border-radius:12px;
    border:2px solid #000;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    box-shadow:0 10px 22px rgba(0,0,0,.18);
    cursor:pointer;
    user-select:none;
    touch-action:manipulation;
  }
  .side-card:active{ transform:translateY(1px); }

  /* =========================
     ★チッププール（サイズはJSで人数に合わせて可変）
     ========================= */
  .chip-pool{
    position:fixed;
    right:12px;
    top:68px;
    width:220px;       /* ←初期値（JSで上書き） */
    height:150px;      /* ←初期値（JSで上書き） */
    background:rgba(255,255,255,.92);
    backdrop-filter: blur(6px);
    border:2px solid #000;
    border-radius:16px;
    box-shadow:none;
    z-index:200; /* ★変更：手札(170/500)より後ろへ */
    overflow:hidden;
    display:flex;
    flex-direction:column;
    pointer-events:auto;
  }
  .chip-pool.hidden{ display:none; }
  .chip-pool-header{ display:none; }
  .chip-pool-area{
    position:relative;
    flex:1 1 auto;
    overflow:hidden;
  }
  .chip-item{
    position:absolute;
    width:var(--chip-d);
    height:var(--chip-d);
    border-radius:999px;
    touch-action:none;  /* ★ドラッグ用（ここは維持） */
    cursor:grab;
    user-select:none;
  }
  .chip-item.dragging{ cursor:grabbing; }
  .chip-item svg{ width:100%; height:100%; display:block; }

  .chip-floating{
    position:fixed;
    left:0; top:0;
    z-index:10000;
    pointer-events:none;
  }

  #dragLayer{
    position:fixed; inset:0;
    z-index:9999;
    pointer-events:none;
  }

  /* =========================================================
     ：手札公開の「最強5枚＋役」演出（中央に2秒）
     - 英語表記
     - ポップなフォント
     ========================================================= */
  .hand-result-pop{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    z-index:2147483646;
    pointer-events:none;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .hand-result-pop.hidden{ display:none; }

 .hand-result-card{
    position:relative;
    width:min(420px, calc(100vw - 28px));
    border-radius:18px;
    border:1px solid rgba(255,255,255,.22);
    background:
      radial-gradient(circle at 20% 20%, rgba(255,255,255,.22), rgba(255,255,255,0) 55%),
      radial-gradient(circle at 80% 30%, rgba(255,255,255,.16), rgba(255,255,255,0) 60%),
      linear-gradient(180deg, rgba(15,15,20,.92), rgba(10,10,14,.90));
    box-shadow:0 22px 60px rgba(0,0,0,.55);
    padding:12px 12px 10px;
    overflow:hidden;
    transform-origin:center;
    will-change: transform, opacity;
    animation: handPop 3.8s cubic-bezier(.22,.84,.44,1) both;
  }
  .hand-result-card::before{
    content:'';
    position:absolute; inset:-40px;
    background:
      radial-gradient(circle at 30% 20%, rgba(255, 215, 0, .22), rgba(255,255,255,0) 55%),
      radial-gradient(circle at 70% 80%, rgba(0, 255, 200, .16), rgba(255,255,255,0) 60%);
    filter: blur(10px);
    opacity:.75;
    pointer-events:none;
  }
  .hand-result-card::after{
    content:'';
    position:absolute; inset:0;
    background:
      repeating-linear-gradient(45deg, rgba(255,255,255,.06) 0 2px, rgba(255,255,255,0) 2px 7px);
    opacity:.25;
    pointer-events:none;
  }

  .hand-result-top{
    position:relative;
    display:flex;
    align-items:baseline;
    justify-content:space-between;
    gap:10px;
    z-index:1;
    flex-wrap:wrap;
  }
  .hand-result-title{
    font-family:'Fredoka','Baloo 2',system-ui,sans-serif;
    font-weight:700;
    font-size:20px;
    letter-spacing:.02em;
    color:#fff;
    text-shadow:0 10px 30px rgba(0,0,0,.45);
    line-height:1.1;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .hand-result-sub{
    font-family:'Baloo 2','Fredoka',system-ui,sans-serif;
    font-weight:800;
    font-size:12px;
    color:rgba(255,255,255,.78);
    letter-spacing:.06em;
    text-transform:uppercase;
    white-space:nowrap;
  }

  .hand-result-cards{
    position:relative;
    z-index:1;
    display:flex;
    justify-content:center;
    gap:8px;
    margin-top:10px;
  }

  .hand-result-cards .pcard,
  .hand-result-cards .backcard{
    width:72px !important;
    height:108px !important;
    border-radius:10px !important;
    box-shadow:0 10px 26px rgba(0,0,0,.45) !important;
    border-color:rgba(255,255,255,.35) !important;
  }
  .hand-result-cards .pcard .corner .rank{ font-size:12px !important; }
  .hand-result-cards .pcard .corner .suit{ font-size:12px !important; }
  .hand-result-cards .pcard .pip{ font-size:16px !important; }
  .hand-result-cards .pcard[data-rank="A"] .pip{ font-size:34px !important; }
  .hand-result-cards .pcard .face-holder{ font-size:36px !important; }
  .hand-result-cards .pcard .face-suit{ font-size:26px !important; }

  @keyframes handPop{
    0%   { opacity:0; transform:translateY(8px) scale(.9); }
    12%  { opacity:1; transform:translateY(0px) scale(1.02); }
    20%  { opacity:1; transform:translateY(0px) scale(1.00); }
    85%  { opacity:1; transform:translateY(0px) scale(1.00); }
    100% { opacity:0; transform:translateY(-4px) scale(.98); }
  }

/* =========================
   ：左下の2つの山札（独立機能）
   ========================= */
.ex-two-decks{
  position:fixed;
  left:16px;
  bottom:76px; /* 左下ボタン(？)と干渉しないように少し上 */
  z-index:260;
  display:flex;
  gap:10px;
  pointer-events:auto;
}
.ex-two-decks.hidden{ display:none; }

.ex-deck-stack{
  width:54px;
  height:78px;
  position:relative;
  border-radius:10px;
  cursor:pointer;
  user-select:none;
  pointer-events:auto;
}
.ex-deck-stack.empty{
  outline:1px dashed rgba(0,0,0,.35);
  outline-offset:-4px;
  background:rgba(0,0,0,.06);
  box-shadow:none;
}

.ex-deck-layer{
  position:absolute;
  inset:0;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.65);
  overflow:hidden;
  background:
    radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
    repeating-linear-gradient(45deg, rgba(255,255,255,.10) 0 2px, rgba(255,255,255,0) 2px 6px),
    linear-gradient(135deg, rgba(185,28,28,.95), rgba(127,29,29,.95));
}
.ex-deck-layer::after{
  content:'';
  position:absolute;
  inset:6px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,.45);
  box-shadow:inset 0 0 0 1px rgba(0,0,0,.15);
}

.ex-deck-count{
  position:absolute;
  right:-6px;
  top:-8px;
  min-width:22px;
  height:18px;
  padding:0 6px;
  display:flex;
  align-items:center;
  justify-content:center;
  border-radius:999px;
  background:rgba(0,0,0,.55);
  color:#fff;
  font-size:11px;
  font-weight:900;
  border:1px solid rgba(255,255,255,.25);
  pointer-events:none;
}

/* 追加で出現するカード（手札と同サイズ：60x90） */
.ex-float-card{
  position:fixed;
  width:60px;
  height:90px;
  border-radius:8px;
  border:2px solid #111;
  background:#fff;
  box-shadow:0 10px 22px rgba(0,0,0,.20);
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:900;
  font-size:22px;
  letter-spacing:.02em;
  user-select:none;
  touch-action:none; /* ドラッグ用 */
  cursor:grab;
}
.ex-float-card:active{ cursor:grabbing; }

.ex-float-card .ex-mini{
  position:absolute;
  inset:0;
  border-radius:6px;
  margin:6px;
  border:1px solid rgba(0,0,0,.15);
  pointer-events:none;
}
.ex-float-card .ex-label{
  position:relative;
  z-index:1;
}
.ex-float-card.ex-challenge{ color:#b91c1c; }
.ex-float-card.ex-specialist{ color:#111; }

/* 追加機能専用ダイアログ（既存ダイアログには干渉しない） */
#exDialogBackdrop{ z-index:99999; }

/* =========================================================
   ★裏面画像 差し替え（CSSだけで対応・既存ロジック無変更）
   - 通常カード裏面 / 中央の山札 / 配布フライカード：gangura.jpg
   - 左下 追加山札（左）：specialyama.jpg
   - 左下 追加山札（右）：challengeyama.jpg
   ========================================================= */

/* 画像ファイルはHTMLと同じフォルダに置く前提 */
:root{
  --card-back-url: url('gangura.jpg');
  --ex-spec-back-url: url('specialyama.jpg');
  --ex-chal-back-url: url('challengeyama.jpg');
}

/* ① トランプ裏面（場札の裏・手札の裏） */
.backcard{
  background: var(--card-back-url) center/cover no-repeat !important;
}

/* ② 中央の山札の見た目（積層レイヤー） */
.deck-layer{
  background: var(--card-back-url) center/cover no-repeat !important;
}

/* ③ 配布アニメで飛ぶカード（fly-card）も同じ裏面に */
.fly-card{
  background: var(--card-back-url) center/cover no-repeat !important;
}

/* ④ 左下の追加山札：左（スペシャリスト） */
#exSpecStack{
  background: var(--ex-spec-back-url) center/cover no-repeat !important;
}
#exSpecStack .ex-deck-layer{
  background: var(--ex-spec-back-url) center/cover no-repeat !important;
}

/* ⑤ 左下の追加山札：右（チャレンジ） */
#exChalStack{
  background: var(--ex-chal-back-url) center/cover no-repeat !important;
}
#exChalStack .ex-deck-layer{
  background: var(--ex-chal-back-url) center/cover no-repeat !important;
}


/* 絵札画像用のスタイル */
.face-image-container {
  position: absolute;
  inset: 14px 10px;
  border-radius: 8px;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

.face-image-container img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  object-position: center;
}

/* =========================
   ★スペシャル9：全回収→シャッフル→再配布 演出
   ========================= */
/* =========================
   ★スペシャル9：全回収→シャッフル→再配布 演出
   ========================= */
.s9-layer{
  position:fixed;
  inset:0;
  z-index:2147483645;
  pointer-events:none;
}
.s9-layer.hidden{ display:none; }

.s9-fly{
  position:fixed;
  width:52px;              /* ★60→52（ちょい小さく） */
  height:78px;             /* ★90→78（ちょい小さく） */
  border-radius:8px;
  border:1px solid rgba(255,255,255,.65);
  overflow:hidden;
  box-shadow:0 10px 22px rgba(0,0,0,.22);
  transform-origin:center;
  pointer-events:none;
  /* 既存の裏面（gangura.jpg）をそのまま使う */
  background: var(--card-back-url) center/cover no-repeat !important;
}
.s9-fly::after{
  content:'';
  position:absolute; inset:5px;   /* ★6→5（小さくした分だけ少し詰める） */
  border-radius:6px;
  border:1px solid rgba(255,255,255,.45);
  box-shadow:inset 0 0 0 1px rgba(0,0,0,.15);
}


/* 中央でシャッフルっぽく揺らす */
@keyframes s9ShuffleJitter{
  0%   { transform:translate(-50%,-50%) rotate(0deg)  scale(1); }
  15%  { transform:translate(-50%,-50%) rotate(6deg)  scale(1.02); }
  30%  { transform:translate(-50%,-50%) rotate(-7deg) scale(1.01); }
  45%  { transform:translate(-50%,-50%) rotate(10deg) scale(1.03); }
  60%  { transform:translate(-50%,-50%) rotate(-8deg) scale(1.01); }
  75%  { transform:translate(-50%,-50%) rotate(5deg)  scale(1.02); }
  100% { transform:translate(-50%,-50%) rotate(0deg)  scale(1); }
}
/* ★追加：スペシャル9中は「自分の手札」を隠す（レイアウトは維持） */
.my-hand.s9-hand-hidden{
  opacity:0;
  pointer-events:none;
}

.player-wrap.fan-hand-hidden .player-tag .mini-hand,
.player-wrap.fan-hand-hidden .player-tag .reveal-hand{
  opacity:0;
  visibility:hidden;
}

.player-wrap.special6-pulse .mini-card{
  animation: special6Pulse .8s ease-in-out infinite;
}
.player-tag .special6-picked-mini{
  position:absolute;
  left:100%;
  top:100%;
  transform:translate(6px, 3px);
}
.my-hand .special6-picked{
  margin-right:14px;
}
.my-hand .special6-picked .pcard,
.my-hand .special6-picked .backcard{
  border:2px solid #f97316;
  box-shadow:0 6px 16px rgba(249,115,22,.35);
}

/* ★追加：EXCHANGE開始と同時に、選んだカードを「見た目だけ」消す */
.my-hand.special6-exchanging .special6-hide-now{
  visibility:hidden;
  opacity:0;
}

/* ★追加：束の箱サイズをカードサイズに合わせて持たせる */
.s9-shuffle-stack{
  position:fixed;
  width:52px;   /* .s9-fly と同じ */
  height:78px;  /* .s9-fly と同じ */
  transform:translate(-50%,-50%);
  animation:s9ShuffleJitter .9s cubic-bezier(.22,.84,.44,1) both;
}


</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">リンクコピー</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">
      <div id="centerTable" class="center-table">
        <div id="deckStack" class="deck-stack empty" title="山札">
          <div id="deckCount" class="deck-count">52</div>
        </div>
        <div id="boardRow" class="board-row" aria-label="場札">
          <div class="board-slot" data-slot="0"></div>
          <div class="board-slot" data-slot="1"></div>
          <div class="board-slot" data-slot="2"></div>
          <div class="board-slot" data-slot="3"></div>
          <div class="board-slot" data-slot="4"></div>
        </div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>
<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<!-- ：左上カード（マネー/サイレン） -->
<div id="sideCards" class="side-cards hidden" aria-label="サイドカード">
  <div id="moneyRow" class="side-row" aria-label="マネーカード"></div>
  <div id="sirenRow" class="side-row" aria-label="サイレンカード"></div>
</div>

<div id="chipPool" class="chip-pool hidden" aria-label="チッププール">
  <div class="chip-pool-header">
    <div class="chip-pool-title"></div>
    <div class="chip-pool-sub" id="chipPoolSub"></div>
  </div>
  <div id="chipPoolArea" class="chip-pool-area"></div>
</div>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で山札(52)を生成し、全プレイヤーへ2枚ずつ配布。<br>
    場札は最初0枚です。山札クリックで「裏3枚→場札クリックで順に表→山札で最大5枚」。
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<!-- ：手札公開の役演出（中央2秒） -->
<div id="handResultPop" class="hand-result-pop hidden" aria-hidden="true">
  <div class="hand-result-card" id="handResultCard">
    <div class="hand-result-top">
      <div class="hand-result-title" id="handResultTitle">STRAIGHT FLUSH</div>
      <div class="hand-result-sub" id="handResultSub">PLAYER</div>
    </div>
    <div class="hand-result-cards" id="handResultCards"></div>
  </div>
</div>

<!-- =========================
     ：スペシャル1（相手画面中央に3秒表示）
     ========================= -->
<div id="specialCardShow" class="special-card-show hidden" aria-hidden="true">
  <div class="special-card-panel">
    <p id="specialCardShowName" class="special-card-name">PLAYER</p>
    <div id="specialCardShowCard" class="special-card-slot"></div>
  </div>
</div>


<!-- =========================
     ：左下の2つの山札（独立機能）
     ========================= -->
<div id="exTwoDecks" class="ex-two-decks hidden" aria-label="追加山札">
  <div id="exSpecStack" class="ex-deck-stack" title="スペシャリスト山札">
    <div id="exSpecCount" class="ex-deck-count">10</div>
  </div>

  <div id="exChalStack" class="ex-deck-stack" title="チャレンジ山札">
    <div id="exChalCount" class="ex-deck-count">10</div>
  </div>
</div>

<!-- 機能専用：確認ポップ（既存とは完全分離） -->
<div id="exDialogBackdrop" class="dialog-backdrop hidden">
  <div class="dialog-box">
    <p id="exDialogText">確認</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="exDialogNo">いいえ</button>
      <button class="btn primary" id="exDialogYes">はい</button>
    </div>
  </div>
</div>


<div id="special9Layer" class="s9-layer hidden"></div>
<div id="dragLayer"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue, remove } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

/* =========================
   ★スクロール完全停止（iOS/トラックパッド対策）
   ========================= */
document.addEventListener('touchmove', (e) => {
  e.preventDefault();
}, { passive:false });

document.addEventListener('wheel', (e) => {
  e.preventDefault();
}, { passive:false });

const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qO2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:2986... (省略せずに入れてOK)",
  measurementId: "G-HPDFTCLR8H"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  room: {},
  game: { started:false, deck: [], boardCodes: [], boardFaceUpCount: 0, deal:null },

  dealing: false,
  dealShownCounts: null,

  chipOwners: {},
  chipPoolPos: {},
  chipFaceDown: {},

  ownCircleVisible: true,

  /* ：公開フェーズ（DB: rooms/{room}/reveal） */
  reveal: null,

  /* ：左上カード（DB: rooms/{room}/sideCards） */
  sideCards: null,

  /* ：公開演出の重複防止 */
  _revealPopInited: false,
  _prevRevealed: {},
  _handPopTimer: 0,

  /* =========================
     ：スペシャルカード(1/5)用
     ========================= */
  special: { active:false, mode:null, used:false, _overlayTimer:0 },
  _specialSubInited: false,
  _specialSeen: {},

  /* =========================
     ★スペシャル9用（全回収→シャッフル→再配布）
     ========================= */
  _special9SubInited: false,
  _special9SeenId: null,
  _special9SeenStage: null,
  _special9Running: false,

  /* =========================
     ★スペシャル6用（全員1枚選択→右隣へ渡す）
     ========================= */
  special6: null,
  _special6SubInited: false,
  _special6SeenStage: null,
  _special6Finalizing: false,
  _special6SelectHandSnap: null, // SELECT中に保持する「交換前の自分手札」
  _special6HoldHandSnap: null,   // EXCHANGE中に表示を固定する「交換前の自分手札」

};


const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');

/* ：中央テーブル（捨て札のドロップ判定に使う） */
const centerTable = document.getElementById('centerTable');

/* =========================
   ：スペシャル1用「他プレイヤー ownarea」を自動生成
   - player-wrap が生成されたタイミングで差し込む（既存renderを壊さない）
   ========================= */
function ensureOtherOwnAreas(){
  if (!playerCircle) return;
  const wraps = playerCircle.querySelectorAll('.player-wrap');
  wraps.forEach(w => {
    const pid = w.dataset.pid;
    if (!pid) return;
    if (pid === state.userId) return; // 自分は作らない

    const tag = w.querySelector('.player-tag');
    if (!tag) return;

    // 既に枠があるならOK
    if (w.querySelector('.other-ownarea')) return;

    // player-wrap を基準に absolute を効かせる（既に absolute だが念のため）
    w.style.position = w.style.position || 'absolute';

    const oa = document.createElement('div');
    oa.className = 'other-ownarea';
    oa.textContent = ''; // 囲み枠なので文字は不要

    // ★重要：タグの「背面」に入れて囲む
    // 先頭に入れると、後から出てくる tag より背面になりやすい
    w.insertBefore(oa, w.firstChild);
  });
}


// playerCircle 内のDOM変化を監視して自動差し込み
if (playerCircle){
  const mo = new MutationObserver(() => ensureOtherOwnAreas());
  mo.observe(playerCircle, { childList:true, subtree:true });
}


/* ：スペシャル表示 */
const specialCardShow = document.getElementById('specialCardShow');
const specialCardShowName = document.getElementById('specialCardShowName');
const specialCardShowCard = document.getElementById('specialCardShowCard');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const chipPool = document.getElementById('chipPool');
const chipPoolArea = document.getElementById('chipPoolArea');
const dragLayer = document.getElementById('dragLayer');
const special9Layer = document.getElementById('special9Layer');

/* ：左上カードDOM */
const sideCardsEl = document.getElementById('sideCards');
const moneyRowEl  = document.getElementById('moneyRow');
const sirenRowEl  = document.getElementById('sirenRow');

/* ：手札公開 演出DOM */
const handResultPop   = document.getElementById('handResultPop');
const handResultCard  = document.getElementById('handResultCard');
const handResultTitle = document.getElementById('handResultTitle');
const handResultSub   = document.getElementById('handResultSub');
const handResultCards = document.getElementById('handResultCards');

const ROLE_HELP = [
  { 
    name: "ロイヤルフラッシュ", 
    text: "同じスートのA, K, Q, J, 10。最強の役です。\n・同じ役同士の場合は引き分け。",
    example: ["♥A", "♥K", "♥Q", "♥J", "♥10"],
    highlight: [0, 1, 2, 3, 4]
  },
  { 
    name: "ストレートフラッシュ", 
    text: "同じスートで数字が連続した5枚。\n・同じ場合は高い数字のストレートが勝ち。\n・A-2-3-4-5は一番弱いストレート。",
    example: ["♥7", "♥8", "♥9", "♥10", "♥J"],
    highlight: [0, 1, 2, 3, 4]
  },
  { 
    name: "フォーカード", 
    text: "同じ数字のカード4枚。\n・まず4枚の数字を比較（高い方が勝ち）。\n・同じ場合はキッカー（残り1枚）を比較。",
    example: ["♠K", "♥K", "♦K", "♣K", "♥2"],
    highlight: [0, 1, 2, 3]
  },
  { 
    name: "フルハウス", 
    text: "スリーカードとワンペアの組み合わせ。\n・まずスリーカードの数字を比較。\n・同じ場合はペアの数字を比較。",
    example: ["♠5", "♥5", "♦5", "♣Q", "♥Q"],
    highlight: [0, 1, 2, 3, 4]
  },
  { 
    name: "フラッシュ", 
    text: "同じスートのカード5枚。\n・数字の高い順に比較（高い方が勝ち）。\n・すべて同じ場合は引き分け。",
    example: ["♠A", "♠J", "♠9", "♠6", "♠3"],
    highlight: [0, 1, 2, 3, 4]
  },
  { 
    name: "ストレート", 
    text: "スートがバラバラでも数字が連続した5枚。\n・高い数字のストレートが勝ち。\n・A-2-3-4-5は一番弱いストレート。",
    example: ["♠3", "♥4", "♦5", "♣6", "♠7"],
    highlight: [0, 1, 2, 3, 4]
  },
  { 
    name: "スリーカード", 
    text: "同じ数字のカード3枚。\n・まずスリーカードの数字を比較。\n・同じ場合は残り2枚の高い順に比較（キッカー）。",
    example: ["♠J", "♥J", "♦J", "♣5", "♥2"],
    highlight: [0, 1, 2]
  },
  { 
    name: "ツーペア", 
    text: "ペアが2組。\n・高い方のペアを比較。\n・同じ場合は低い方のペアを比較。\n・それも同じ場合はキッカーで比較。",
    example: ["♠9", "♥9", "♦A", "♣A", "♠2"],
    highlight: [0, 1, 2, 3]
  },
  { 
    name: "ワンペア", 
    text: "ペアが1組。\n・まずペアの数字を比較。\n・同じ場合は残り3枚を高い順に比較。",
    example: ["♠K", "♥K", "♦5", "♣8", "♠2"],
    highlight: [0, 1]
  },
  { 
    name: "ハイカード", 
    text: "役が成立しない場合。\n・一番高いカードを比較。\n・同じ場合は次に高いカードを比較。\n・すべて同じ場合は引き分け。",
    example: ["♥A", "♠K", "♥J", "♠9", "♣7"],
    highlight: [0],
    specialExample: {
      title: "タイ",
      description: "二人ともワンペア（5）を作っています。もう一枚のカードはBさんのほうが高いが、どちらのカードも場より低いので採用せず、タイ（同率）になります。",
      centerCards: ["♥5", "♠A", "♠K", "♠Q", "♠J"], // 場のカード5枚
      leftCards: ["♠5", "♥2"], // Aさんの手札2枚
      rightCards: ["♦5", "♥4"], // Bさんの手札2枚
      highlightCenter: [0], // 場の5
      highlightLeft: [0], // Aさんの5（ワンペアの一部）
      highlightRight: [0], // Bさんの5（ワンペアの一部）
      showCenterPair: [0, 0] // 場の5と手札の5がペアになることを示す
    }
  }
];

function renderHelpList(){
  helpBody.innerHTML = '';
  
  // ポップアップのタイトルを変更
  const helpTitle = document.querySelector('.help-pop-title');
  if (helpTitle) {
    helpTitle.textContent = 'ポーカーの役';
  }
  
  ROLE_HELP.forEach((r, idx) => {
    const row = document.createElement('div');
    row.className = 'role-row';
    
    // 左側：カードの例を表示
    const cardContainer = document.createElement('div');
    cardContainer.className = 'role-card';
    cardContainer.style.cssText = `
      width: 180px;
      height: 98px;
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #f8f8f8;
      box-shadow: 0 4px 12px rgba(0,0,0,.08);
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: visible;
    `;
    
    // 5枚のカードを重ねて表示
    const cards = r.example || [];
    const highlights = r.highlight || [];
    
    cards.forEach((cardCode, cardIndex) => {
      const cardEl = createCardElement(cardCode);
      
      // 強調するカードかどうかで透明度を調整
      const isHighlighted = highlights.includes(cardIndex);
      
      cardEl.style.cssText = `
        position: absolute;
        width: 45px !important;
        height: 68px !important;
        left: ${15 + cardIndex * 22}px;
        z-index: ${cards.length - cardIndex};
        transform: rotate(${cardIndex === 2 ? '0' : cardIndex < 2 ? '-2' : '2'}deg);
        box-shadow: 0 2px 6px rgba(0,0,0,.15);
        opacity: ${isHighlighted ? '1' : '0.5'};
        filter: ${isHighlighted ? 'none' : 'brightness(0.9)'};
      `;
      
      // 強調されていないカードはさらに色を薄く
      if (!isHighlighted) {
        cardEl.style.filter = 'brightness(0.85) saturate(0.8)';
      }
      
      // 角の文字を小さく
      const corners = cardEl.querySelectorAll('.corner');
      corners.forEach(corner => {
        corner.querySelectorAll('.rank, .suit').forEach(el => {
          el.style.fontSize = '7px';
        });
      });
      
      // 絵札/数字の調整
      const faceHolder = cardEl.querySelector('.face-holder');
      if (faceHolder) faceHolder.style.fontSize = '16px';
      const faceSuit = cardEl.querySelector('.face-suit');
      if (faceSuit) faceSuit.style.fontSize = '12px';
      const pips = cardEl.querySelectorAll('.pip');
      pips.forEach(pip => {
        pip.style.fontSize = '9px';
      });
      const aPip = cardEl.querySelector('[data-rank="A"] .pip');
      if (aPip) aPip.style.fontSize = '18px';
      
      cardContainer.appendChild(cardEl);
    });
    
    // 右側：説明
    const desc = document.createElement('div');
    desc.className = 'role-desc';
    
    // 名前部分
    const nameEl = document.createElement('div');
    nameEl.className = 'name';
    nameEl.textContent = `${idx + 1}. ${r.name}`;
    
    // 説明部分（改行を保持するためにpre-wrapを使用）
    const textEl = document.createElement('div');
    textEl.className = 'text';
    textEl.style.cssText = `
      font-size: 12px;
      line-height: 1.5;
      color: #222;
      white-space: pre-wrap;
      margin-top: 4px;
    `;
    textEl.textContent = r.text;
    
    desc.appendChild(nameEl);
    desc.appendChild(textEl);
    
    row.appendChild(cardContainer);
    row.appendChild(desc);
    helpBody.appendChild(row);
    
    // 特別な例がある場合（ハイカードの場合）
    if (r.specialExample) {
      const specialRow = document.createElement('div');
      specialRow.className = 'role-row';
      specialRow.style.cssText = `
        margin-top: 20px;
        padding-top: 15px;
        border-top: 2px dashed #ccc;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
      `;
      
      // タイトル
      const titleEl = document.createElement('div');
      titleEl.className = 'name';
      titleEl.style.cssText = `
        font-size: 14px;
        font-weight: bold;
        color: #333;
        margin-bottom: 10px;
        text-align: center;
        width: 100%;
      `;
      titleEl.textContent = r.specialExample.title;
      
      // 特別な例の説明
      const specialDesc = document.createElement('div');
      specialDesc.className = 'text';
      specialDesc.style.cssText = `
        font-size: 12px;
        line-height: 1.4;
        color: #222;
        margin-bottom: 15px;
        text-align: center;
        max-width: 400px;
      `;
      specialDesc.textContent = r.specialExample.description;
      
      // 広い枠（カード配置用）- 小さく修正
      const specialCardContainer = document.createElement('div');
      specialCardContainer.style.cssText = `
        width: 360px;
        height: 220px;
        border-radius: 10px;
        border: 2px solid #aaa;
        background: #f0f0f0;
        position: relative;
        margin-bottom: 10px;
      `;
      
      // 中央の5枚（場のカード）- 小さく修正
      const centerCards = r.specialExample.centerCards || [];
      const centerHighlights = r.specialExample.highlightCenter || [];
      const showCenterPair = r.specialExample.showCenterPair || [];
      
      centerCards.forEach((cardCode, cardIndex) => {
        const cardEl = createCardElement(cardCode);
        const isHighlighted = centerHighlights.includes(cardIndex);
        const isPair = showCenterPair[0] === cardIndex;
        
        cardEl.style.cssText = `
          position: absolute;
          width: 52px !important;
          height: 78px !important;
          left: ${60 + cardIndex * 52}px;
          top: 60px;
          z-index: ${centerCards.length - cardIndex + 10};
          transform: rotate(${cardIndex === 2 ? '0' : cardIndex < 2 ? '-3' : '3'}deg);
          box-shadow: 0 3px 8px rgba(0,0,0,.25);
          opacity: ${isHighlighted ? '1' : '0.7'};
          filter: ${isHighlighted ? 'none' : 'brightness(0.8) saturate(0.7)'};
        `;
        
        // ペアになるカードは枠で強調
        if (isPair) {
          cardEl.style.boxShadow = '0 0 0 2px #ff9900, 0 3px 8px rgba(0,0,0,.25)';
        }
        
        // 角の文字サイズ調整
        const corners = cardEl.querySelectorAll('.corner');
        corners.forEach(corner => {
          corner.querySelectorAll('.rank, .suit').forEach(el => {
            el.style.fontSize = '8px';
          });
        });
        
        // 絵札/数字の調整
        const faceHolder = cardEl.querySelector('.face-holder');
        if (faceHolder) faceHolder.style.fontSize = '18px';
        const faceSuit = cardEl.querySelector('.face-suit');
        if (faceSuit) faceSuit.style.fontSize = '14px';
        const pips = cardEl.querySelectorAll('.pip');
        pips.forEach(pip => {
          pip.style.fontSize = '10px';
        });
        const aPip = cardEl.querySelector('[data-rank="A"] .pip');
        if (aPip) aPip.style.fontSize = '20px';
        
        specialCardContainer.appendChild(cardEl);
      });
      
      // 左下の2枚（Aさんの手札）- 小さく修正
      const leftCards = r.specialExample.leftCards || [];
      const leftHighlights = r.specialExample.highlightLeft || [];
      leftCards.forEach((cardCode, cardIndex) => {
        const cardEl = createCardElement(cardCode);
        const isHighlighted = leftHighlights.includes(cardIndex);
        const isPair = showCenterPair[1] === cardIndex;
        
        cardEl.style.cssText = `
          position: absolute;
          width: 44px !important;
          height: 66px !important;
          left: ${25 + cardIndex * 24}px;
          top: 130px;
          z-index: ${leftCards.length - cardIndex};
          transform: rotate(${cardIndex === 0 ? '-12' : '-8'}deg);
          box-shadow: 0 2px 6px rgba(0,0,0,.2);
          opacity: ${isHighlighted ? '1' : '0.5'};
          filter: ${isHighlighted ? 'none' : 'brightness(0.7) saturate(0.6)'};
        `;
        
        // ペアになるカードは枠で強調
        if (isPair) {
          cardEl.style.boxShadow = '0 0 0 2px #ff9900, 0 2px 6px rgba(0,0,0,.2)';
        }
        
        // 角の文字サイズ調整
        const corners = cardEl.querySelectorAll('.corner');
        corners.forEach(corner => {
          corner.querySelectorAll('.rank, .suit').forEach(el => {
            el.style.fontSize = '7px';
          });
        });
        
        specialCardContainer.appendChild(cardEl);
      });
      
      // 右下の2枚（Bさんの手札）- 小さく修正
      const rightCards = r.specialExample.rightCards || [];
      const rightHighlights = r.specialExample.highlightRight || [];
      rightCards.forEach((cardCode, cardIndex) => {
        const cardEl = createCardElement(cardCode);
        const isHighlighted = rightHighlights.includes(cardIndex);
        const isPair = showCenterPair[1] === cardIndex;
        
        cardEl.style.cssText = `
          position: absolute;
          width: 44px !important;
          height: 66px !important;
          left: ${270 + cardIndex * 24}px;
          top: 130px;
          z-index: ${rightCards.length - cardIndex};
          transform: rotate(${cardIndex === 0 ? '8' : '12'}deg);
          box-shadow: 0 2px 6px rgba(0,0,0,.2);
          opacity: ${isHighlighted ? '1' : '0.5'};
          filter: ${isHighlighted ? 'none' : 'brightness(0.7) saturate(0.6)'};
        `;
        
        // ペアになるカードは枠で強調
        if (isPair) {
          cardEl.style.boxShadow = '0 0 0 2px #ff9900, 0 2px 6px rgba(0,0,0,.2)';
        }
        
        // 角の文字サイズ調整
        const corners = cardEl.querySelectorAll('.corner');
        corners.forEach(corner => {
          corner.querySelectorAll('.rank, .suit').forEach(el => {
            el.style.fontSize = '7px';
          });
        });
        
        specialCardContainer.appendChild(cardEl);
      });
      
      // ペアを示す線（場の5と手札の5を結ぶ）
      if (showCenterPair.length >= 2) {
        // Aさんのペア線
        const lineA = document.createElement('div');
        lineA.style.cssText = `
          position: absolute;
          left: 112px;
          top: 110px;
          width: 50px;
          height: 1.5px;
          background: linear-gradient(90deg, rgba(255,153,0,0.7), rgba(255,153,0,0.3));
          transform: rotate(-25deg);
          z-index: 5;
        `;
        specialCardContainer.appendChild(lineA);
        
        // Bさんのペア線
        const lineB = document.createElement('div');
        lineB.style.cssText = `
          position: absolute;
          left: 200px;
          top: 110px;
          width: 50px;
          height: 1.5px;
          background: linear-gradient(90deg, rgba(255,153,0,0.7), rgba(255,153,0,0.3));
          transform: rotate(25deg);
          z-index: 5;
        `;
        specialCardContainer.appendChild(lineB);
      }
      
      // ラベル追加
      const labelStyle = `
        position: absolute;
        font-size: 10px;
        font-weight: bold;
        color: #555;
        background: rgba(255,255,255,0.8);
        padding: 2px 6px;
        border-radius: 3px;
        z-index: 20;
      `;
      
      const centerLabel = document.createElement('div');
      centerLabel.textContent = '場のカード';
      centerLabel.style.cssText = labelStyle + 'left: 140px; top: 25px;';
      specialCardContainer.appendChild(centerLabel);
      
      const leftLabel = document.createElement('div');
      leftLabel.textContent = 'Aさん';
      leftLabel.style.cssText = labelStyle + 'left: 30px; top: 205px;';
      specialCardContainer.appendChild(leftLabel);
      
      const rightLabel = document.createElement('div');
      rightLabel.textContent = 'Bさん';
      rightLabel.style.cssText = labelStyle + 'left: 285px; top: 205px;';
      specialCardContainer.appendChild(rightLabel);
      
      specialRow.appendChild(titleEl);
      specialRow.appendChild(specialDesc);
      specialRow.appendChild(specialCardContainer);
      helpBody.appendChild(specialRow);
    }
  });
}
function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

/* =========================
   ：スペシャルカード1/5 ダブルクリック
   - ex-float-card の表示文字が "1" / "5" のとき発動
   ========================= */
document.addEventListener('dblclick', async (e) => {
  const card = e.target.closest('.ex-float-card');
  if (!card) return;

  const v = (card.dataset.value || card.textContent || '').trim();
  if (v === '1'){
    startSpecial1();
  } else if (v === '5'){
    await startSpecial5();
  } else if (v === '6'){
    await startSpecial6();
  } else if (v === '7'){
    await startSpecial7(card); // ★追加：スペシャル7
  } else if (v === '9'){
    await startSpecial9();
  }
}, { capture:true });





let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

let isDealAnimating = false;
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

/* =========================================================
   ：スペシャルカード(1/5)
   - 1: 手札パルス→手札カードをドラッグ→他人のownarea(=player-wrap)へドロップ
       → 相手画面中央に3秒表示（カード上にプレイヤー名）
   - 5: 山札から1枚ドロー（ドローアニメ）→手札パルス→中央(=centerTable)へ1枚捨て札→終了
   ========================================================= */

function setHandSpecialUI(on){
  myHandEl.classList.toggle('special-pulse', !!on);
  myHandEl.classList.toggle('special-dragging', !!on);
}
function pointInRect(x,y,r){
  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}
function getOtherPidUnderPoint(x,y){
  // ★スペシャル1は「相手のネームタグ周辺（囲み枠）」に落としたら反応
  const wraps = playerCircle.querySelectorAll('.player-wrap');
  for (const w of wraps){
    const pid = w?.dataset?.pid;
    if (!pid || pid === state.userId) continue;

    // 枠が存在する相手だけ対象（special1用）
    const oa = w.querySelector('.other-ownarea');
    if (!oa) continue;

    // 囲み領域は player-wrap の矩形を使う（タグ＋チップ等を含むが、囲みとして安定）
const r = oa.getBoundingClientRect();   
    if (pointInRect(x,y,r)) return pid;
  }
  return null;
}



function isPointInCenter(x,y){
  // ★変更：スペシャル5は「playercircleの中（円の内側）」なら捨てられる
  const el = playerCircle;
  if (!el) return false;

  const r = el.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top  + r.height/2;
  const rad = Math.min(r.width, r.height) / 2;

  const dx = x - cx;
  const dy = y - cy;
  return (dx*dx + dy*dy) <= (rad*rad);
}



function showSpecialCardCenter(playerName, cardCode){
  if (!specialCardShow) return;
  specialCardShowName.textContent = String(playerName || 'PLAYER');
  specialCardShowCard.innerHTML = '';
  specialCardShowCard.appendChild(createCardElement(cardCode));
  specialCardShow.classList.remove('hidden');

  if (state.special._overlayTimer) clearTimeout(state.special._overlayTimer);
  state.special._overlayTimer = setTimeout(() => {
    specialCardShow.classList.add('hidden');
  }, 3000);
}

async function emitSpecialEvent(ev){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/specialEvents/${id}`), {
    ...ev,
    id,
    at: Date.now()
  });
}

/* =========================================================
   ★スペシャル9：全員の手札を中央へ回収→シャッフル→均等に再配布
   - DB: rooms/{room}/special9 を監視して全員同時アニメ
   - stage:
      COLLECT  : 回収→中央へ集める
      DEAL     : 再配布（このタイミングで hands をDB更新）
      DONE     : 終了
   ========================================================= */

function getActivePlayerIdsForS9(){
  // 1) latestPlayers があるなら優先
  const a = (latestPlayers || []).map(p => p?.id).filter(Boolean);
  if (a.length) return Array.from(new Set(a));

  // 2) fallback: DOMから
  const wraps = playerCircle?.querySelectorAll?.('.player-wrap') || [];
  const b = Array.from(wraps).map(w => w?.dataset?.pid).filter(Boolean);
  return Array.from(new Set(b));
}

async function getHandsSnapshot(pids){
  const out = {};
  await Promise.all(pids.map(async pid => {
    try{
      const snap = await get(ref(db, `rooms/${state.roomCode}/hands/${pid}/cards`));
      const arr = Array.isArray(snap.val()) ? snap.val() : [];
      out[pid] = arr.slice();
    }catch(e){
      out[pid] = [];
    }
  }));
  return out;
}

function shuffleCopy(arr){
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function getCenterPoint(){
  // ★回収＆配布の中心は「サークル(playerCircle)の中心」に固定
  const pr = playerCircle?.getBoundingClientRect?.();
  if (pr) return { x: pr.left + pr.width/2, y: pr.top + pr.height/2 };

  // fallback（念のため）
  return { x: window.innerWidth/2, y: window.innerHeight/2 };
}

function getSourcePointForPid(pid){
  // 自分は「手札の中心」から
  if (pid === state.userId){
    const r = myHandEl?.getBoundingClientRect?.();
    if (r) return { x: r.left + r.width/2, y: r.top + r.height/2 };
  }
  // 他人はネームタグの位置から
  const w = playerCircle?.querySelector?.(`.player-wrap[data-pid="${pid}"] .player-tag`);
  const r = w?.getBoundingClientRect?.();
  if (r) return { x: r.left + r.width/2, y: r.top + r.height/2 };

  // fallback
  return getCenterPoint();
}

function getTargetPointForPid(pid){
  // DEAL時：自分は手札へ、他人はネームタグへ
  return getSourcePointForPid(pid);
}

function s9ShowLayer(){
  if (!special9Layer) return;
  special9Layer.innerHTML = '';
  special9Layer.classList.remove('hidden');
}
function s9HideLayer(){
  if (!special9Layer) return;
  special9Layer.classList.add('hidden');
  special9Layer.innerHTML = '';
}

function s9SetMyHandHidden(on){
  if (!myHandEl) return;
  myHandEl.classList.toggle('s9-hand-hidden', !!on);
}

function setFanHandHiddenForPid(pid, on){
  if (!pid) return;
  const wrap = document.querySelector(`.player-wrap[data-pid="${pid}"]`);
  if (!wrap) return;
  wrap.classList.toggle('fan-hand-hidden', !!on);
}

function setFanHandHiddenForAll(on){
  const wraps = document.querySelectorAll('.player-wrap');
  wraps.forEach(wrap => {
    wrap.classList.toggle('fan-hand-hidden', !!on);
  });
}



function s9MakeFlyCard(x, y, rotDeg = 0){
  // ★CSSの .s9-fly（52x78）に合わせる
  const HW = 26; // 52/2
  const HH = 39; // 78/2

  const el = document.createElement('div');
  el.className = 's9-fly';
  el.style.left = `${x - HW}px`;
  el.style.top  = `${y - HH}px`;
  el.style.transform = `rotate(${rotDeg}deg)`;
  return el;
}

function s9AnimateFly(el, toX, toY, dur = 520, extraRot = 0, scale = 0.96, delay = 0){
  // ★CSSの .s9-fly（52x78）に合わせる
  const HW = 26; // 52/2
  const HH = 39; // 78/2

  return new Promise(res => {
    requestAnimationFrame(() => {
      const fromLeft = Number(String(el.style.left).replace('px','')) || 0;
      const fromTop  = Number(String(el.style.top ).replace('px','')) || 0;

      // 「現在の中心座標」
      const curX = fromLeft + HW;
      const curY = fromTop  + HH;

      const dx = toX - curX;
      const dy = toY - curY;

      el.style.transition =
        `transform ${dur}ms cubic-bezier(.22,.84,.44,1) ${delay}ms, `+
        `left ${dur}ms cubic-bezier(.22,.84,.44,1) ${delay}ms, `+
        `top ${dur}ms cubic-bezier(.22,.84,.44,1) ${delay}ms, `+
        `opacity ${dur}ms cubic-bezier(.22,.84,.44,1) ${delay}ms`;

      // left/top で動かす（transformと競合しない）
      el.style.left = `${fromLeft + dx}px`;
      el.style.top  = `${fromTop  + dy}px`;
      el.style.transform = `rotate(${extraRot}deg) scale(${scale})`;
      el.style.opacity = '1';

      setTimeout(() => res(), dur + delay + 20);
    });
  });
}

async function runSpecial9Collect(ev){
  if (!special9Layer) return;
  s9ShowLayer();

  // ★追加：回収〜配布終了まで自分の手札を隠す（新しい手札が途中で見えないように）
  s9SetMyHandHidden(true);
  setFanHandHiddenForAll(true);

  const center = getCenterPoint();
  const counts = ev.countsByPid || {};
  const pids = ev.order || getActivePlayerIdsForS9();

  // 回収：各プレイヤー位置から中央へ
  const promises = [];
  for (const pid of pids){
    const c = Math.max(0, Number(counts[pid] || 0));
    if (!c) continue;

    const src = getSourcePointForPid(pid);
    for (let i=0;i<c;i++){
      const rot = (Math.random()*24 - 12);
      const el = s9MakeFlyCard(src.x + (Math.random()*10-5), src.y + (Math.random()*10-5), rot);
      special9Layer.appendChild(el);

      const toX = center.x + (Math.random()*18 - 9);
      const toY = center.y + (Math.random()*18 - 9);
      const dur = 420 + Math.floor(Math.random()*220);
      const delay = Math.floor(Math.random()*120);

      promises.push(s9AnimateFly(el, toX, toY, dur, rot + (Math.random()*30-15), 0.95, delay));
    }
  }
  await Promise.all(promises);

  // 中央シャッフル演出（束を軽く揺らす）
  const stack = document.createElement('div');
  stack.className = 's9-shuffle-stack';

  // ★修正：シャッフル束の座標を「サークル中心(px)」に固定
  stack.style.left = `${center.x}px`;
  stack.style.top  = `${center.y}px`;

  // 見た目はカード3枚重ね
  for (let i=0;i<3;i++){
    const card = document.createElement('div');
    card.className = 's9-fly';
    card.style.position = 'absolute';
    card.style.left = `${(i*2)}px`;
    card.style.top  = `${(i*2)}px`;
    card.style.transform = `rotate(${(i-1)*3}deg)`;
    stack.appendChild(card);
  }
  special9Layer.appendChild(stack);

  // 既に集まった飛びカードは消して、束だけ残す
  const flies = special9Layer.querySelectorAll('.s9-fly');
  flies.forEach(el => {
    if (el.parentNode === stack) return;
    el.remove();
  });

  await sleep(920);
}


async function runSpecial9Deal(ev){
  if (!special9Layer) return;

  // ★追加：DEAL中も手札を隠しておく（DB更新で新手札が先に見えるのを防ぐ）
  s9SetMyHandHidden(true);
  setFanHandHiddenForAll(true);

  const center = getCenterPoint();
  const newCounts = ev.newCountsByPid || {};
  const pids = ev.order || getActivePlayerIdsForS9();

  // 束を消す
  const stack = special9Layer.querySelector('.s9-shuffle-stack');
  if (stack) stack.remove();

  // 再配布：中央から各プレイヤーへ
  const promises = [];
  for (const pid of pids){
    const c = Math.max(0, Number(newCounts[pid] || 0));
    if (!c) continue;

    const dst = getTargetPointForPid(pid);
    for (let i=0;i<c;i++){
      const rot = (Math.random()*24 - 12);
      const el = s9MakeFlyCard(center.x + (Math.random()*16-8), center.y + (Math.random()*18-9), rot);
      el.style.opacity = '1';
      special9Layer.appendChild(el);

      const dur = 440 + Math.floor(Math.random()*220);
      const delay = Math.floor(i * 35);
      promises.push(
        s9AnimateFly(el, dst.x + (Math.random()*10-5), dst.y + (Math.random()*10-5), dur, rot + (Math.random()*30-15), 0.98, delay)
          .then(() => el.remove())
      );
    }
  }

  await Promise.all(promises);

  // ★追加：配布演出が終わったら手札を戻す
  s9SetMyHandHidden(false);
  setFanHandHiddenForAll(false);

  s9HideLayer();
}


/* ---- DB購読：special9 ---- */
function subscribeSpecial9(){
  const s9Ref = ref(db, `rooms/${state.roomCode}/special9`);
  onValue(s9Ref, async (snap) => {
    const ev = snap.val();
    if (!ev || !ev.id || !ev.stage) return;

    // 同じid+stageを二重実行しない
    const key = `${ev.id}:${ev.stage}`;
    if (state._special9SeenStage === key) return;
    state._special9SeenStage = key;

    // 既に他stageの途中でも、stageに合わせて動く
    // ただしアニメ中の多重起動は抑止
    if (state._special9Running && ev.stage === 'COLLECT') return;

    // 時間がずれて参加した人でも破綻しにくいよう、遅すぎる場合は短縮/スキップ気味に
    const now = Date.now();
    const baseAt = Number(ev.at || now);
    const late = Math.max(0, now - baseAt);

if (ev.stage === 'COLLECT'){
  state._special9Running = true;
  s9SetMyHandHidden(true);     // ★追加
  setFanHandHiddenForAll(true);
  await runSpecial9Collect(ev);

} else if (ev.stage === 'DEAL'){
  s9SetMyHandHidden(true);     // ★追加（DEAL単独で来ても隠す）
  setFanHandHiddenForAll(true);
  if (!special9Layer?.classList?.contains('hidden') || late < 60000){
    await runSpecial9Deal(ev); // runSpecial9Deal内で最後に戻す
  } else {
    // かなり遅い：演出省略して即終了
    s9HideLayer();
    s9SetMyHandHidden(false);  // ★追加：必ず戻す
    setFanHandHiddenForAll(false);
  }
  state._special9Running = false;

} else if (ev.stage === 'DONE'){
  s9HideLayer();
  s9SetMyHandHidden(false);    // ★追加：必ず戻す
  setFanHandHiddenForAll(false);
  state._special9Running = false;
}

  });
}

/* ---- トリガー：自分が9をダブルクリック ---- */
async function startSpecial9(){
  if (!state.roomCode) return;

  // 既に進行中なら無視
  try{
    const curSnap = await get(ref(db, `rooms/${state.roomCode}/special9`));
    const cur = curSnap.val();
    if (cur && cur.stage && cur.stage !== 'DONE') return;
  }catch(e){}

  const order = getActivePlayerIdsForS9();
  if (!order.length) return;

  // 現在の手札を読み取る
  const hands = await getHandsSnapshot(order);

  // プール化
  const pool = [];
  const countsByPid = {};
  for (const pid of order){
    const arr = Array.isArray(hands[pid]) ? hands[pid] : [];
    countsByPid[pid] = arr.length;
    pool.push(...arr);
  }
  const total = pool.length;
  if (!total) return;

  // stage: COLLECT を書く（全員同時に回収アニメ開始）
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/special9`), {
    id,
    at: Date.now(),
    stage: 'COLLECT',
    fromPid: state.userId,
    fromName: state.userName,
    order,
    countsByPid
  });

  // 少し待って、シャッフル→均等再配布（このタイミングでhandsをDB更新）→全員DEAL演出
  // 均等： total を人数で割り、余りは先頭から+1（＝できるだけ均等）
  const COLLECT_AND_SHUFFLE_MS = 1600; // 回収+シャッフル演出の見せ時間
  const DEAL_ANIM_MS = 1400;

  setTimeout(async () => {
    try{
      // 念のため最新のhandsを再取得（途中で変わっても破綻しにくく）
      const hands2 = await getHandsSnapshot(order);
      const pool2 = [];
      for (const pid of order){
        const arr = Array.isArray(hands2[pid]) ? hands2[pid] : [];
        pool2.push(...arr);
      }
      const shuffled = shuffleCopy(pool2);

      const n = order.length;
      const base = Math.floor(shuffled.length / n);
      let rem = shuffled.length % n;

      const newHandsByPid = {};
      const newCountsByPid = {};
      let idx = 0;
      for (const pid of order){
        const take = base + (rem > 0 ? 1 : 0);
        if (rem > 0) rem--;
        const slice = shuffled.slice(idx, idx + take);
        idx += take;
        newHandsByPid[pid] = slice;
        newCountsByPid[pid] = slice.length;
      }

      // hands更新 + stage: DEAL を同時反映（全員がDEAL演出へ）
      const patch = {};
      for (const pid of order){
        patch[`hands/${pid}/cards`] = newHandsByPid[pid];
      }
      patch[`special9`] = {
        id,
        at: Date.now(),
        stage: 'DEAL',
        fromPid: state.userId,
        fromName: state.userName,
        order,
        countsByPid,
        newCountsByPid
      };

      await update(ref(db, `rooms/${state.roomCode}`), patch);

      // 少し待ってDONE
      setTimeout(async () => {
        try{
          await set(ref(db, `rooms/${state.roomCode}/special9`), {
            id,
            at: Date.now(),
            stage: 'DONE'
          });
        }catch(e){}
      }, DEAL_ANIM_MS + 180);

    }catch(e){}
  }, COLLECT_AND_SHUFFLE_MS);
}

/* =========================================================
   ★スペシャル6：全員1枚選択→右隣へ渡す
   - DB: rooms/{room}/special6
   - stage:
      SELECT   : 全員選択中（再選択OK）
      EXCHANGE : 交換反映＆アニメ
      DONE     : 終了
   ========================================================= */
function getActivePlayerIdsForS6(){
  const a = (latestPlayers || []).map(p => p?.id).filter(Boolean);
  if (a.length) return Array.from(new Set(a));
  return getActivePlayerIdsForS9();
}

function getSpecial6Selection(pid){
  return state.special6?.selections?.[pid] || null;
}

// ★追加：EXCHANGE開始の瞬間に、選んだカードを「見た目だけ」隠す
function markMySpecial6PickedCardHidden(ev){
  if (!myHandEl) return;

  const pid = state.userId;
  const sel = ev?.selections?.[pid] || null;
  const given = (ev?.givenCards?.[pid] || '').trim();

  // 1) index優先（SELECTで選んだ位置が取れるならそれを使う）
  if (sel && Number.isInteger(sel.index)){
    const wrap = myHandEl.querySelector(`.my-card[data-index="${sel.index}"]`);
    if (wrap){
      // もしcodeも一致確認したい場合（安全側）
      const codeNow = (wrap.querySelector('.pcard')?.dataset?.code || '').trim();
      if (!sel.code || sel.code === codeNow){
        wrap.classList.add('special6-hide-now');
        return;
      }
    }
  }

  // 2) codeで探す（given優先 → なければsel.code）
  const targetCode = (given || (sel?.code || '')).trim();
  if (targetCode){
    // codeは通常 "A♠" 的な記号ではなく内部コードなのでほぼ安全（念のため最低限エスケープ）
    const safe = targetCode.replace(/["\\]/g, '\\$&');
    const cardEl = myHandEl.querySelector(`.pcard[data-code="${safe}"]`);
    const wrap = cardEl?.closest('.my-card');
    if (wrap){
      wrap.classList.add('special6-hide-now');
      return;
    }
  }
}

// ★追加：一時的に付けた“消す”クラスを掃除
function clearSpecial6HideNow(){
  if (!myHandEl) return;
  myHandEl.querySelectorAll('.special6-hide-now').forEach(el => {
    el.classList.remove('special6-hide-now');
  });
}


async function selectSpecial6Card(index, code){
  if (!state.roomCode) return;
  const ev = state.special6;
  if (!ev || ev.stage !== 'SELECT') return;
  if (!Number.isInteger(index) || index < 0) return;
  if (!code) return;
  await set(ref(db, `rooms/${state.roomCode}/special6/selections/${state.userId}`), {
    index,
    code,
    at: Date.now()
  });
}

async function finalizeSpecial6IfReady(ev){
  if (!state.isHost || state._special6Finalizing) return;
  if (!ev || ev.stage !== 'SELECT') return;
  const order = Array.isArray(ev.order) ? ev.order : [];
  if (!order.length) return;
  const selections = ev.selections || {};
  const allSelected = order.every(pid => selections[pid] && selections[pid].code !== undefined);
  if (!allSelected) return;

  state._special6Finalizing = true;
  try{
    const hands = await getHandsSnapshot(order);
    const givenCards = {};
    const receivedCards = {};
    const newHandsByPid = {};

    order.forEach(pid => {
      const hand = Array.isArray(hands[pid]) ? hands[pid].slice() : [];
      const sel = selections[pid];
      let chosen = null;
      if (sel && Number.isInteger(sel.index) && sel.index >= 0 && sel.index < hand.length && hand[sel.index] === sel.code){
        chosen = hand.splice(sel.index, 1)[0];
      } else if (sel && sel.code){
        const idx = hand.indexOf(sel.code);
        if (idx >= 0){
          chosen = hand.splice(idx, 1)[0];
        }
      }
      if (!chosen && hand.length){
        chosen = hand.shift();
      }
      givenCards[pid] = chosen || null;
      newHandsByPid[pid] = hand;
    });

    order.forEach((pid, i) => {
      const nextPid = order[(i + 1) % order.length];
      receivedCards[nextPid] = givenCards[pid] || null;
    });

    order.forEach(pid => {
      const incoming = receivedCards[pid];
      if (incoming) newHandsByPid[pid].push(incoming);
    });

    const patch = {};
    order.forEach(pid => {
      patch[`hands/${pid}/cards`] = newHandsByPid[pid];
    });
    patch[`special6`] = {
      id: ev.id,
      at: Date.now(),
      stage: 'EXCHANGE',
      order,
      selections,
      givenCards,
      receivedCards
    };

    await update(ref(db, `rooms/${state.roomCode}`), patch);

    setTimeout(async () => {
      try{
        await set(ref(db, `rooms/${state.roomCode}/special6`), {
          id: ev.id,
          at: Date.now(),
          stage: 'DONE'
        });
      }catch(e){}
    }, 1400);
  } finally {
    state._special6Finalizing = false;
  }
}

async function runSpecial6ExchangeAnimation(ev){
  const pid = state.userId;
  const given = ev?.givenCards?.[pid];
  const received = ev?.receivedCards?.[pid];
  if (!given && !received) return;

  const handRect = myHandEl?.getBoundingClientRect?.();
  const centerX = handRect ? (handRect.left + handRect.width / 2) : (window.innerWidth / 2);
  const centerY = handRect ? (handRect.top + handRect.height / 2) : (window.innerHeight / 2);

  // アニメーション時間を調整（1500ms → 1200ms）
  const animationDuration = 1200;
  
  if (given){
    const outX = -80;
    await animateOneFly(centerX, centerY, outX, centerY, -6, animationDuration);
  }
  if (received){
    const inX = window.innerWidth + 80;
    await animateOneFly(inX, centerY, centerX, centerY, 6, animationDuration);
  }
}
function subscribeSpecial6(){
  const s6Ref = ref(db, `rooms/${state.roomCode}/special6`);
  onValue(s6Ref, async (snap) => {
    const ev = snap.val();
    if (!ev || !ev.id || !ev.stage) {
      state.special6 = null;
      state._special6HoldHandSnap = null; // クリア
      renderHands();
      return;
    }

    state.special6 = {
      active: ev.stage !== 'DONE',
      id: ev.id,
      stage: ev.stage,
      order: ev.order || [],
      selections: ev.selections || {},
      givenCards: ev.givenCards || {},
      receivedCards: ev.receivedCards || {}
    };

    const key = `${ev.id}:${ev.stage}`;
    if (state._special6SeenStage !== key){
      state._special6SeenStage = key;

      if (ev.stage === 'EXCHANGE'){
        // ★修正：現在の手札をスナップショットとして保存
        const myHand = state.hands[state.userId];
        state._special6HoldHandSnap = myHand ? [...(myHand.cards || [])] : [];

        // ★追加：アニメ開始と同時に「選んだカードが消える」を揃える
        myHandEl?.classList.add('special6-exchanging');
        markMySpecial6PickedCardHidden(ev);

        // 1フレーム描画を挟む
        await sleep(16);

        // アニメーション実行
        await runSpecial6ExchangeAnimation(ev);

        // ★修正：アニメーション終了後、スナップショットをクリアして実際の手札を表示
        setTimeout(() => {
          state._special6HoldHandSnap = null;
          myHandEl?.classList.remove('special6-exchanging');
          clearSpecial6HideNow();
          renderHands(); // 実際の手札を再描画
        }, 100); // 少し遅延させて確実にアニメーション終了後になるように
      }
    }

    if (ev.stage === 'SELECT'){
      finalizeSpecial6IfReady(ev).catch(()=>{});
    }

    // ★修正：EXCHANGEステージ中は手札を再描画しない
    if (ev.stage !== 'EXCHANGE') {
      renderHands();
    }

    if (ev.stage === 'DONE'){
      state.special6 = null;
      state._special6HoldHandSnap = null;
      renderHands();
    }
  });
}
async function startSpecial6(){
  if (!state.roomCode) return;
  try{
    const curSnap = await get(ref(db, `rooms/${state.roomCode}/special6`));
    const cur = curSnap.val();
    if (cur && cur.stage && cur.stage !== 'DONE') return;
  }catch(e){}

  const order = getActivePlayerIdsForS6();
  if (!order.length) return;

  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/special6`), {
    id,
    at: Date.now(),
    stage: 'SELECT',
    order,
    selections: {}
  });
}

/* ---- トリガー：自分が7をダブルクリック ----
   仕様：
   - ダブルクリックした本人の手札に「スート無しJ(11)」を追加
   - クリック用のこのカード（ex-float-card）は消す
*/
const SPECIAL7_CODE = 'J_'; // ★スート無しJ(11)を表す内部コード（スートは "_"）

// ★追加：カードコードを「役計算/描画」共通で解釈する
function decodeCardCode(code){
  const s = String(code || '').trim();
  if (!s) return { raw:s, rankStr:'', rank:0, suit:null, isSuitless:false };

  const last = s.slice(-1);
  const isSuitless = (last === '_');            // ← スート無しは "_" 終端
  const suit = isSuitless ? null : last;        // ← スート無しは null
  const rankStr = s.slice(0, -1);               // ← 末尾1文字はスート(または"_")なので除去

  // ランク数値化（J=11）
  let rank = 0;
  if (rankStr === 'A') rank = 14;
  else if (rankStr === 'K') rank = 13;
  else if (rankStr === 'Q') rank = 12;
  else if (rankStr === 'J') rank = 11;
  else rank = Number(rankStr);

  return { raw:s, rankStr, rank, suit, isSuitless };
}


async function startSpecial7(cardEl){
  if (!state.roomCode) return;

  // 1) クリック用カードを消す（まずUIから）
  try{ cardEl?.remove?.(); }catch(e){}

  // 2) 手札に追加（DB同期）
  // あなたのコード内の drawOneFromDeckToMe() と同じ「hands/{pid}/cards」へ追記方式で統一する
  const handRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}/cards`);

  const snap = await get(handRef);
  const myCards = Array.isArray(snap.val()) ? snap.val() : [];

  // 重複したら増やさない（好みで外してOK）
  // if (myCards.includes(SPECIAL7_CODE)) return;

  const newHand = [...myCards, SPECIAL7_CODE];
  await set(handRef, newHand);
}


function subscribeSpecialEvents(){
  state._specialSubInited = true;
  const evRef = ref(db, `rooms/${state.roomCode}/specialEvents`);
  onValue(evRef, (snap) => {
    const all = snap.val() || {};
    for (const [id, ev] of Object.entries(all)){
      if (!ev) continue;
      if (state._specialSeen[id]) continue;

      // 宛先が自分なら処理
      if (ev.toPid && ev.toPid !== state.userId) continue;

      state._specialSeen[id] = true;

      if (ev.type === 'S1_SHOW'){
        showSpecialCardCenter(ev.toName || getPlayerName(ev.toPid) || 'PLAYER', ev.cardCode);

        // 受信側が掃除（溜まらないように）
        setTimeout(() => {
          remove(ref(db, `rooms/${state.roomCode}/specialEvents/${id}`)).catch(()=>{});
        }, 3500);
      }
    }
  });
}

function endSpecialMode(){
  state.special.active = false;
  state.special.mode = null;
  state.special.used = false;
  setHandSpecialUI(false);

  // ：表示クラス解除
  playerCircle?.classList.remove('special1-active');
  playerCircle?.classList.remove('discard-active');
}

/* ---- スペシャル1開始 ---- */
function startSpecial1(){
  if (state.special.active) return;
  state.special.active = true;
  state.special.mode = 'S1';
  state.special.used = false;
  setHandSpecialUI(true);

  // ：相手ownareaを確実に作って強調
  ensureOtherOwnAreas();
  playerCircle?.classList.add('special1-active');
}

/* ---- スペシャル5開始（ドロー→捨て札1枚） ---- */
async function startSpecial5(){
  if (state.special.active) return;
  state.special.active = true;
  state.special.mode = 'S5';
  state.special.used = false;
  setHandSpecialUI(true);

  // ：playercircle内＝捨て場表示
  playerCircle?.classList.add('discard-active');

  const drawn = await drawOneFromDeckToMe();
  if (drawn) await playDrawAnimFromDeckToHand();
}

/* 山札から1枚引いて自分の手札に追加（DB同期） */
async function drawOneFromDeckToMe(){
  if (!state.roomCode) return null;

  const deckRef = ref(db, `rooms/${state.roomCode}/game/deck`);
  const handRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}/cards`);

  const deckSnap = await get(deckRef);
  const deck = deckSnap.val();
  if (!Array.isArray(deck) || deck.length === 0) return null;

  // このコードでは deal が deck.splice(0,cnt) なので「先頭がトップ」扱いに揃える
  const code = deck[0];
  const newDeck = deck.slice(1);

  const handSnap = await get(handRef);
  const myCards = Array.isArray(handSnap.val()) ? handSnap.val() : [];
  const newHand = [...myCards, code];

  const patch = {};
  patch[`game/deck`] = newDeck;
  patch[`hands/${state.userId}/cards`] = newHand;

  await update(ref(db, `rooms/${state.roomCode}`), patch);
  return code;
}

/* ドローアニメ（山札→手札）※見た目はfly-cardを流用 */
async function playDrawAnimFromDeckToHand(){
  const deckEl = document.getElementById('deckStack');
  if (!deckEl || !myHandEl) return;

  const from = deckEl.getBoundingClientRect();
  const to = myHandEl.getBoundingClientRect();

  const fly = document.createElement('div');
  fly.className = 'fly-card';
  fly.style.left = `${from.left}px`;
  fly.style.top  = `${from.top}px`;
  fly.style.opacity = '1';
  fly.style.transform = 'translate(0px,0px) scale(1)';
  document.body.appendChild(fly);

  await sleep(16);

  const dx = (to.left + to.width/2) - (from.left + from.width/2);
  const dy = (to.top  + to.height/2) - (from.top  + from.height/2);

  fly.style.transition = 'transform .46s cubic-bezier(.22,.84,.44,1), opacity .46s';
  fly.style.transform = `translate(${dx}px, ${dy}px) scale(.92)`;
  fly.style.opacity = '0.06';

  await sleep(520);
  fly.remove();
}

/* 手札から1枚捨てる（DB同期） */
async function discardOneFromMyHand(cardCode){
  if (!state.roomCode) return;

  const handRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}/cards`);
  const snap = await get(handRef);
  const arr = Array.isArray(snap.val()) ? snap.val().slice() : [];

  const idx = arr.indexOf(cardCode);
  if (idx < 0) return;

  arr.splice(idx, 1);

  const discardId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  const patch = {};
  patch[`hands/${state.userId}/cards`] = arr;
  patch[`discard/${discardId}`] = { by: state.userId, cardCode, at: Date.now() };

  await update(ref(db, `rooms/${state.roomCode}`), patch);
}

/* =========================
   ★ 左上カード（マネー/サイレン）
   ========================= */
const SIDE_CARD_SPECS = {
  money: { front: 'moneyomote.jpg', back: 'moneyura.jpg' },
  siren: { front: 'silenomote.jpg', back: 'silenura.jpg' },
};

function getSideArr(group){
  const sc = state.sideCards || {};
  const g = sc[group];

  if (Array.isArray(g)){
    return [!!g[0], !!g[1], !!g[2]];
  }
  if (g && typeof g === 'object'){
    return [!!g[0], !!g[1], !!g[2]];
  }
  return [false, false, false];
}

function renderSideCards(){
  if (joinBox.classList.contains('hidden')) sideCardsEl.classList.remove('hidden');

  const money = getSideArr('money');
  const siren = getSideArr('siren');

  const makeRow = (rowEl, group, arr) => {
    rowEl.innerHTML = '';
    for (let i=0; i<3; i++){
      const isFront = !!arr[i];
      const spec = SIDE_CARD_SPECS[group];
      const el = document.createElement('div');
      el.className = 'side-card';
      el.dataset.group = group;
      el.dataset.idx = String(i);
      el.style.backgroundImage = `url('${isFront ? spec.front : spec.back}')`;

      el.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        await toggleSideCard(group, i);
      });

      rowEl.appendChild(el);
    }
  };

  makeRow(moneyRowEl, 'money', money);
  makeRow(sirenRowEl, 'siren', siren);
}

async function toggleSideCard(group, idx){
  if (!state.roomCode) return;
  const curArr = getSideArr(group);
  const cur = !!curArr[idx];
  try{
    await set(ref(db, `rooms/${state.roomCode}/sideCards/${group}/${idx}`), !cur);
  }catch(e){}
}

async function ensureSideCardsExistsIfHost(){
  if (!state.isHost || !state.roomCode) return;
  const scRef = ref(db, `rooms/${state.roomCode}/sideCards`);
  const snap = await get(scRef);
  if (!snap.exists()){
    await set(scRef, {
      money: { 0:false, 1:false, 2:false },
      siren: { 0:false, 1:false, 2:false }
    });
    return;
  }
  const v = snap.val() || {};
  const patch = {};
  for (const g of ['money','siren']){
    for (let i=0;i<3;i++){
      const has = (v[g] && (v[g][i] !== undefined));
      if (!has) patch[`${g}/${i}`] = false;
    }
  }
  if (Object.keys(patch).length){
    try{ await update(scRef, patch); }catch(e){}
  }
}

function subscribeSideCards(){
  const scRef = ref(db, `rooms/${state.roomCode}/sideCards`);
  onValue(scRef, snap => {
    state.sideCards = snap.val() || null;
    renderSideCards();
  });
}

/* =========================
   ★ 公開フェーズ（赤チップ全消え→赤★1→★2→…）
   ========================= */
function getMaxPlayers(){
  const n = Number(state.room?.maxPlayers || 0);
  return Number.isFinite(n) ? n : 0;
}
function allRedChipIds(n){
  const out = [];
  for (let i=1; i<=n; i++) out.push(`赤_${i}`);
  return out;
}
function getRevealCurrentPid(){
  const r = state.reveal;
  if (!r || !r.active || !Array.isArray(r.order)) return null;
  const t = Number(r.turn || 0);
  return r.order[t] || null;
}
function isMyRevealTurn(){
  const cur = getRevealCurrentPid();
  if (!cur) return false;
  if (cur !== state.userId) return false;
  if (state.reveal?.revealed?.[state.userId]) return false;
  return true;
}
async function revealMyHand(){
  if (!state.roomCode) return;
  if (!isMyRevealTurn()) return;

  const revealRef = ref(db, `rooms/${state.roomCode}/reveal`);
  const snap = await get(revealRef);
  const r = snap.val();
  if (!r || !r.active || !Array.isArray(r.order)) return;

  const order = r.order;
  const turn = Number(r.turn || 0);
  const curPid = order[turn];
  if (curPid !== state.userId) return;

  const revealed = r.revealed || {};
  if (revealed[state.userId]) return;

  revealed[state.userId] = true;

  let next = turn + 1;
  while (next < order.length && revealed[order[next]]) next++;

  const patch = { revealed };
  if (next >= order.length){
    patch.active = false;
    patch.turn = order.length;
    patch.endedAt = Date.now();
  } else {
    patch.turn = next;
  }

  await update(revealRef, patch);
}

let _startingReveal = false;
async function maybeStartRevealPhaseIfReady(){
  if (_startingReveal) return;
  if (!state.isHost || !state.roomCode) return;

  const n = getMaxPlayers();
  if (!n) return;

  const revealRef = ref(db, `rooms/${state.roomCode}/reveal`);
  const curSnap = await get(revealRef);
  const cur = curSnap.val();
  if (cur && cur.startedAt) return;

  const owners = state.chipOwners || {};
  const redIds = allRedChipIds(n);
  const unowned = redIds.filter(id => !owners[id]);
  if (unowned.length > 0) return;

  _startingReveal = true;
  try{
    const entries = [];
    redIds.forEach(id => {
      const owner = owners[id];
      if (!owner) return;
      const parts = String(id).split('_');
      const i = Number(parts[1] || 0);
      const stars = ((i - 1) % 6) + 1;
      entries.push({ owner, stars, i });
    });
    entries.sort((a,b) => (a.stars - b.stars) || (a.i - b.i));

    const seen = new Set();
    const order = [];
    for (const e of entries){
      if (!e.owner) continue;
      if (seen.has(e.owner)) continue;
      seen.add(e.owner);
      order.push(e.owner);
    }

    if (!order.length) return;

    await set(revealRef, {
      active: true,
      order,
      turn: 0,
      revealed: {},
      startedAt: Date.now()
    });
  } finally {
    _startingReveal = false;
  }
}

myHandEl.addEventListener('click', (e) => {
  if (state.special?.active) return;   // ：スペシャル中はここを動かさない

  if (state.special6?.active && state.special6.stage === 'SELECT'){
    const cardEl = e.target.closest('.pcard');
    if (!cardEl) return;
    const wrap = cardEl.closest('.my-card');
    const idx = Number(wrap?.dataset?.index);
    const code = (cardEl.dataset.code || '').trim();
    if (Number.isFinite(idx) && code){
      selectSpecial6Card(idx, code);
      e.preventDefault();
      e.stopPropagation();
      return;
    }
  }

  if (state.special6?.active) return;
  if (isMyRevealTurn()) revealMyHand();
});

/* =========================
   ：スペシャル中の手札ドラッグ
   ========================= */
let _handDrag = null;

function onHandDragMove(ev){
  if (!_handDrag) return;
  ev.preventDefault();
  const left = ev.clientX - _handDrag.offX;
  const top  = ev.clientY - _handDrag.offY;
  _handDrag.ghost.style.left = `${left}px`;
  _handDrag.ghost.style.top  = `${top}px`;
}

async function onHandDragUp(ev){
  if (!_handDrag) return;
  ev.preventDefault();

  window.removeEventListener('pointermove', onHandDragMove);
  window.removeEventListener('pointerup', onHandDragUp);
  window.removeEventListener('pointercancel', onHandDragUp);

  const { code, srcEl, ghost } = _handDrag;
  _handDrag = null;

  if (ghost && ghost.parentNode) ghost.remove();
  if (srcEl && srcEl.isConnected) srcEl.style.visibility = '';

  // ---- S1: 他人player-wrapへドロップで相手画面中央に3秒表示 → 終了
  if (state.special.active && state.special.mode === 'S1'){
    const toPid = getOtherPidUnderPoint(ev.clientX, ev.clientY);
    if (toPid){
      await emitSpecialEvent({
        type:'S1_SHOW',
        fromPid: state.userId,
        fromName: state.userName,
        toPid,
        toName: getPlayerName(toPid),
        cardCode: code
      });
      endSpecialMode();
    }
    return;
  }

  // ---- S5: 中央へドロップで捨て札1枚 → 終了
  if (state.special.active && state.special.mode === 'S5'){
    if (!state.special.used && isPointInCenter(ev.clientX, ev.clientY)){
      state.special.used = true;
      await discardOneFromMyHand(code);
      endSpecialMode();
    }
    return;
  }
}

myHandEl.addEventListener('pointerdown', (e) => {
  if (!state.special?.active) return;

  const cardEl = e.target.closest('.pcard');
  if (!cardEl) return;

  const code = (cardEl.dataset.code || '').trim();
  if (!code) return;

  e.preventDefault();
  e.stopPropagation();

  const r = cardEl.getBoundingClientRect();

  const ghost = document.createElement('div');
  ghost.className = 'fly-card';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width  = `${r.width}px`;
  ghost.style.height = `${r.height}px`;
  ghost.style.pointerEvents = 'none';
  ghost.style.zIndex = '10000';
  ghost.innerHTML = cardEl.outerHTML; // 見た目をそのまま

  document.body.appendChild(ghost);
  cardEl.style.visibility = 'hidden';

  _handDrag = {
    code,
    srcEl: cardEl,
    ghost,
    offX: e.clientX - r.left,
    offY: e.clientY - r.top
  };

  window.addEventListener('pointermove', onHandDragMove, { passive:false });
  window.addEventListener('pointerup', onHandDragUp, { passive:false });
  window.addEventListener('pointercancel', onHandDragUp, { passive:false });
}, { passive:false });

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');

  chipPool.classList.toggle('hidden', joinBox.classList.contains('hidden') ? false : true);
  sideCardsEl.classList.toggle('hidden', joinBox.classList.contains('hidden') ? false : true);

  /* ：入室後（roomCodeがある時）に1回だけ購読 */
  if (state.roomCode && !state._specialSubInited){
    subscribeSpecialEvents();
  }
  if (state.roomCode && !state._special9SubInited){
    subscribeSpecial9();               // ★追加
    state._special9SubInited = true;   // ★追加
  }
  if (state.roomCode && !state._special6SubInited){
    subscribeSpecial6();
    state._special6SubInited = true;
  }
}




function setOwnCircleVisible(visible){
  state.ownCircleVisible = !!visible;
  const oc = document.getElementById('ownCircle');
  if (oc){
    oc.classList.toggle('hidden', !state.ownCircleVisible);
  }
}

function updateOwnCircleToFit(){
  const wrap = document.querySelector(`.player-wrap[data-pid="${state.userId}"]`);
  if (!wrap) return;
  const oc = wrap.querySelector('#ownCircle');
  if (!oc) return;

  const pad = 18;
  const w = Math.max(20, wrap.offsetWidth + pad);
  const h = Math.max(20, wrap.offsetHeight + pad);

  oc.style.setProperty('--oc-w', `${Math.round(w)}px`);
  oc.style.setProperty('--oc-h', `${Math.round(h)}px`);
  oc.classList.toggle('hidden', !state.ownCircleVisible);
}
window.addEventListener('resize', () => requestAnimationFrame(updateOwnCircleToFit));

/* =========================
   ★ チップSVG（裏向き対応）
   ========================= */
const CHIP_COLORS = [
  { key:"白", fill:"#F7F7F7", stroke:"#CFCFCF" },
  { key:"黄", fill:"#FFD84A", stroke:"#C9A600" },
  { key:"オレンジ", fill:"#FF9A2F", stroke:"#D06B00" },
  { key:"赤", fill:"#FF4B4B", stroke:"#C82828" },
];
const CHIP_COLOR_MAP = Object.fromEntries(CHIP_COLORS.map(c => [c.key, c]));

const toRad = d => d * Math.PI / 180;
function polar(cx, cy, r, angRad){
  return { x: cx + Math.cos(angRad)*r, y: cy + Math.sin(angRad)*r };
}
function starPolygonPoints(cx, cy, outerR, innerR, spikes = 5, rotationDeg = -90){
  const pts = [];
  const rot = rotationDeg * Math.PI / 180;
  const step = Math.PI / spikes;
  for(let i=0;i<spikes*2;i++){
    const r = (i % 2 === 0) ? outerR : innerR;
    const a = rot + i * step;
    pts.push((cx + Math.cos(a)*r).toFixed(2) + "," + (cy + Math.sin(a)*r).toFixed(2));
  }
  return pts.join(" ");
}
function starPositionsInsideCircle(cx, cy, n, ringR){
  if(n === 1) return [{ x: cx, y: cy }];
  const pos = [];
  const startDeg = -90;
  for(let i=0;i<n;i++){
    const a = (startDeg + (360/n)*i) * Math.PI/180;
    pos.push({ x: cx + Math.cos(a)*ringR, y: cy + Math.sin(a)*ringR });
  }
  return pos;
}
function spokeSectorsData(cx, cy, rInnerEdge, rOuterEdge, spokeThickness, stepDeg = 60, startDeg = -90){
  const midR = (rInnerEdge + rOuterEdge) / 2;
  const halfW = spokeThickness / 2;

  let halfAngle = Math.asin(Math.min(1, halfW / Math.max(1e-6, midR)));
  halfAngle = Math.min(halfAngle, Math.PI/2 - 1e-3);

  const out = [];
  let idx = 0;
  for(let deg = startDeg; deg < startDeg + 360; deg += stepDeg){
    const a = toRad(deg);
    const a1 = a - halfAngle;
    const a2 = a + halfAngle;

    const pIn1  = polar(cx, cy, rInnerEdge, a1);
    const pOut1 = polar(cx, cy, rOuterEdge, a1);
    const pOut2 = polar(cx, cy, rOuterEdge, a2);
    const pIn2  = polar(cx, cy, rInnerEdge, a2);

    const d = [
      `M ${pIn1.x.toFixed(2)} ${pIn1.y.toFixed(2)}`,
      `L ${pOut1.x.toFixed(2)} ${pOut1.y.toFixed(2)}`,
      `A ${rOuterEdge.toFixed(2)} ${rOuterEdge.toFixed(2)} 0 0 1 ${pOut2.x.toFixed(2)} ${pOut2.y.toFixed(2)}`,
      `L ${pIn2.x.toFixed(2)} ${pIn2.y.toFixed(2)}`,
      `A ${rInnerEdge.toFixed(2)} ${rInnerEdge.toFixed(2)} 0 0 0 ${pIn1.x.toFixed(2)} ${pIn1.y.toFixed(2)}`,
      `Z`
    ].join(" ");

    out.push({ d, angle: a, idx });
    idx++;
  }
  return out;
}
function markerOffsets(lineCount, spokeThickness){
  if(lineCount <= 0) return [];
  const spread = spokeThickness * 0.25;
  if(lineCount === 1) return [0];
  if(lineCount === 2) return [-spread * 0.75, spread * 0.75];
  return [-spread, 0, spread];
}
function markerLinesMarkup(spokesData, cx, cy, rInnerEdge, rOuterEdge, spokeThickness, lineCount, lineColor, clipId){
  if(lineCount <= 0) return "";
  const offsets = markerOffsets(lineCount, spokeThickness);
  const sw = 2.2;

  const segs = [];
  for(const sp of spokesData){
    const a = sp.angle;
    for(const t of offsets){
      const daIn  = t / rInnerEdge;
      const daOut = t / rOuterEdge;

      const pIn  = polar(cx, cy, rInnerEdge, a + daIn);
      const pOut = polar(cx, cy, rOuterEdge, a + daOut);

      segs.push(
        `<path d="M ${pIn.x.toFixed(2)} ${pIn.y.toFixed(2)} L ${pOut.x.toFixed(2)} ${pOut.y.toFixed(2)}"
           fill="none" stroke="${lineColor}" stroke-width="${sw}"
           stroke-linecap="round" stroke-linejoin="round" />`
      );
    }
  }

  return `<g clip-path="url(#${clipId})">${segs.join("")}</g>`;
}

function chipSVG(color, stars, uid, faceDown = false){
  const { key, fill, stroke } = color;
  const vb = 100;
  const cx = 50, cy = 50;

  const outerR = 46;
  const outerStroke = 4;

  const innerCircleR = 33;
  const innerStroke = 2.2;

  const spokeThickness = 16;

  const rInnerEdge = innerCircleR + innerStroke/2;
  const rOuterEdge = outerR - outerStroke/2;

  const starOuter = 6.0;
  const starInner = 2.6;
  const starRingR = 12;

  const maxRingR = Math.max(0, innerCircleR - (starOuter + 4 + innerStroke));
  const ringR = Math.min(starRingR, maxRingR);

  const starPts = starPolygonPoints(0, 0, starOuter, starInner);
  const positions = starPositionsInsideCircle(cx, cy, stars, ringR);

  const spokesData = spokeSectorsData(cx, cy, rInnerEdge, rOuterEdge, spokeThickness, 60, -90);
  const spokesMarkup = spokesData.map(s => `<path d="${s.d}" fill="#111" />`).join("");

  const lineCount =
    (key === "黄") ? 1 :
    (key === "オレンジ") ? 2 :
    (key === "赤") ? 3 : 0;

  const clipId = `spokes-clip-${uid}`;
  const coloredLines = markerLinesMarkup(
    spokesData, cx, cy, rInnerEdge, rOuterEdge, spokeThickness,
    lineCount, fill, clipId
  );

  const shadow = `
    <filter id="ds-${uid}" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="0" dy="1.2" stdDeviation="1.2" flood-color="#000" flood-opacity=".15"/>
    </filter>
  `;

  const starFill = faceDown ? fill : "#111";
  const starsMarkup = positions.map(p => (
    `<polygon points="${starPts}" fill="${starFill}" transform="translate(${p.x.toFixed(2)} ${p.y.toFixed(2)})" />`
  )).join("");

  const innerFill = faceDown ? "#111" : "none";

  return `
    <svg viewBox="0 0 ${vb} ${vb}" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="チップ">
      <defs>
        ${shadow}
        <clipPath id="${clipId}">
          ${spokesData.map(s => `<path d="${s.d}"></path>`).join("")}
        </clipPath>
      </defs>

      <circle cx="${cx}" cy="${cy}" r="${outerR}" fill="${fill}" filter="url(#ds-${uid})"/>
      ${spokesMarkup}
      ${coloredLines}
      <circle cx="${cx}" cy="${cy}" r="${outerR}" fill="none" stroke="${stroke}" stroke-width="${outerStroke}"/>
      <circle cx="${cx}" cy="${cy}" r="${innerCircleR}" fill="${innerFill}" stroke="#111" stroke-width="${innerStroke}"/>
      ${starsMarkup}
    </svg>
  `;
}

/* =========================
   ★ チッププール生成
   ========================= */
let chipUid = 0;
let chipState = {
  builtFor: null,
  chips: [],
  draggingId: null,
  dragOffX: 0,
  dragOffY: 0,
  raf: 0,
  dragMeta: {},
  press: null,
  lastTap: {}
};

const DOUBLE_TAP_MS = 320;
const TAP_SLOP_PX   = 6;
const DRAG_START_PX = 7;

function getChipD(){
  const v = getComputedStyle(document.documentElement).getPropertyValue('--chip-d').trim();
  const n = Number(String(v).replace('px',''));
  return Number.isFinite(n) && n > 6 ? n : 24;
}
function setChipDFromTag(){
  const tag = document.querySelector('.player-tag');
  if (!tag) return;
  const h = tag.getBoundingClientRect().height;
  if (h && h > 10){
    document.documentElement.style.setProperty('--chip-d', `${Math.round(h)}px`);
  }
}
function clamp(v, min, max){
  return Math.max(min, Math.min(max, v));
}
function getChipById(id){
  return chipState.chips.find(c => c.id === id) || null;
}
function buildChipSetForPlayers(playerCount){
  const n = Math.max(0, Number(playerCount || 0));
  const chips = [];
  for (let i=1; i<=n; i++){
    const stars = ((i - 1) % 6) + 1;
    for (const c of CHIP_COLORS){
      chips.push({
        id: `${c.key}_${i}`,
        colorKey: c.key,
        stars,
        color: c
      });
    }
  }
  return chips;
}

/* ：人数に応じてチッププールサイズを可変に */
function resizeChipPoolForPlayers(n){
  const d = getChipD();
  const gap = Math.max(2, Math.round(d * 0.18));
  const pad = 10;

  const cols = Math.max(1, Number(n || 1));
  const rows = 4;

  const innerW = pad*2 + cols*d + (cols-1)*gap;
  const innerH = pad*2 + rows*d + (rows-1)*gap;

  chipPool.style.width  = `${Math.round(innerW)}px`;
  chipPool.style.height = `${Math.round(innerH)}px`;
}

/* ★変更：初期配置を「上段 白1..N / 下段 黄 / 下段 オレンジ / 下段 赤」に */
function layoutChipPositions(chips){
  const d = getChipD();
  const gap = Math.max(2, Math.round(d * 0.18));
  const pad = 10;

  const rect = chipPoolArea.getBoundingClientRect();
  const W = rect.width;
  const H = rect.height;

  const rowOrder = { "白":0, "黄":1, "オレンジ":2, "赤":3 };

  chips.forEach((ch) => {
    const [colorKey, numStr] = String(ch.id).split('_');
    const col = Math.max(0, (Number(numStr||1) - 1));
    const row = rowOrder[colorKey] ?? 0;

    const x = pad + col * (d + gap);
    const y = pad + row * (d + gap);

    ch.x = clamp(x, 0, W - d);
    ch.y = clamp(y, 0, H - d);
  });
}

function applyChipTransform(ch){
  if (!ch.el) return;
  ch.el.style.transform = `translate(${ch.x}px, ${ch.y}px)`;
}
function attachChipToPool(ch){
  if (!ch?.el) return;
  if (ch.el.parentNode !== chipPoolArea) chipPoolArea.appendChild(ch.el);
  ch.el.classList.remove('chip-floating');
  ch.el.style.position = 'absolute';
  ch.el.style.left = '';
  ch.el.style.top  = '';
  ch.el.style.transform = `translate(${ch.x}px, ${ch.y}px)`;
  ch.el.style.zIndex = '';
  ch.el.style.pointerEvents = 'auto';
}
function attachChipToDragLayer(ch){
  if (!ch?.el) return;
  if (ch.el.parentNode !== dragLayer) dragLayer.appendChild(ch.el);
  ch.el.classList.add('chip-floating');
  ch.el.style.position = 'fixed';
  ch.el.style.transform = '';
  ch.el.style.zIndex = '10000';
  ch.el.style.pointerEvents = 'none';
}
function isPointInRect(x, y, r){
  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

/* ★ owncircle 当たり判定（楕円） */
function isPointInOwnCircle(x, y){
  const oc = document.getElementById('ownCircle');
  if (!oc || oc.classList.contains('hidden')) return false;
  const r = oc.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top  + r.height/2;
  const rx = Math.max(1, r.width/2);
  const ry = Math.max(1, r.height/2);
  const dx = (x - cx) / rx;
  const dy = (y - cy) / ry;
  return (dx*dx + dy*dy) <= 1;
}

function applyChipOwnersToPool(){
  const owners = state.chipOwners || {};
  chipState.chips.forEach(ch => {
    const owner = owners[ch.id];
    if (owner){
      ch.el.style.display = 'none';
    } else {
      ch.el.style.display = '';
    }
  });
}
function applyChipFacesToPool(){
  if (!chipState.chips.length) return;
  chipState.chips.forEach(ch => {
    if (state.chipOwners && state.chipOwners[ch.id]) return;
    if (chipState.draggingId === ch.id) return;
    const fd = !!state.chipFaceDown?.[ch.id];
    if (ch.faceDown === fd) return;
    ch.faceDown = fd;
    chipUid++;
    if (ch.el) ch.el.innerHTML = chipSVG(ch.color, ch.stars, chipUid, fd);
  });
}

/* ★ 所有チップ描画など */
function parseChipId(chipId){
  const [colorKey, numStr] = String(chipId || '').split('_');
  const n = Number(numStr || 0);
  const color = CHIP_COLOR_MAP[colorKey] || CHIP_COLORS[0];
  const stars = ((n - 1) % 6) + 1;
  return { colorKey, n, stars, color };
}

/* ====== ★変更：所持チップの並びを「色順 白→黄→オレンジ→赤」優先に ====== */
function chipSortKey(chipId){
  const { colorKey, n } = parseChipId(chipId);
  const colorOrder = { "白":0, "黄":1, "オレンジ":2, "赤":3 };
  return [colorOrder[colorKey] ?? 9, n].join('_');
}

let ownedDrag = null;

/* ====== ：チップをプールへ返却（owner解除） ====== */
async function returnChipToPool(chipId){
  if (!state.roomCode) return;
  try{
    await remove(ref(db, `rooms/${state.roomCode}/chipOwners/${chipId}`));
  }catch(e){}
}

function startOwnedChipDrag(e, chipId){
  e.preventDefault();
  e.stopPropagation();

  if (!state.roomCode) return;
  const curOwner = state.chipOwners?.[chipId];
  if (!curOwner) return;

  const srcEl = e.currentTarget;
  if (!srcEl) return;

  const r = srcEl.getBoundingClientRect();
  const ghost = document.createElement('div');
  ghost.className = 'chip-item chip-floating';
  ghost.style.width = `var(--chip-d)`;
  ghost.style.height = `var(--chip-d)`;
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.pointerEvents = 'none';
  ghost.style.zIndex = '10000';
  ghost.innerHTML = srcEl.innerHTML;

  dragLayer.appendChild(ghost);

  srcEl.style.visibility = 'hidden';

  ownedDrag = {
    chipId,
    srcEl,
    ghost,
    offX: e.clientX - r.left,
    offY: e.clientY - r.top
  };

  const onMove = (ev) => {
    if (!ownedDrag) return;
    ev.preventDefault();
    const left = ev.clientX - ownedDrag.offX;
    const top  = ev.clientY - ownedDrag.offY;
    ownedDrag.ghost.style.left = `${left}px`;
    ownedDrag.ghost.style.top  = `${top}px`;
  };

  const onUp = async (ev) => {
    if (!ownedDrag) return;
    ev.preventDefault();

    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);
    window.removeEventListener('pointercancel', onUp);

    const { chipId, srcEl, ghost } = ownedDrag;

    const droppedInOwn = isPointInOwnCircle(ev.clientX, ev.clientY);

    if (ghost && ghost.parentNode) ghost.remove();
    if (srcEl && srcEl.isConnected) srcEl.style.visibility = '';

    ownedDrag = null;

    if (droppedInOwn){
      try{
        await set(ref(db, `rooms/${state.roomCode}/chipOwners/${chipId}`), state.userId);
      }catch(e2){}
    } else {
      await returnChipToPool(chipId);
    }
  };

  window.addEventListener('pointermove', onMove, { passive:false });
  window.addEventListener('pointerup', onUp, { passive:false });
  window.addEventListener('pointercancel', onUp, { passive:false });
}

function renderOwnedChips(){
  const wraps = playerCircle.querySelectorAll('.player-wrap');
  if (!wraps.length) return;

  const owners = state.chipOwners || {};
  const byPlayer = {};
  for (const [chipId, pid] of Object.entries(owners)){
    if (!pid) continue;
    (byPlayer[pid] ||= []).push(chipId);
  }
  for (const pid in byPlayer){
    byPlayer[pid].sort((a,b) => chipSortKey(a).localeCompare(chipSortKey(b)));
  }

  wraps.forEach(w => {
    const pid = w.dataset.pid;
    const box = w.querySelector('.owned-chips');
    if (!box) return;
    box.innerHTML = '';

    const list = byPlayer[pid] || [];
    list.forEach(chipId => {
      const { color, stars } = parseChipId(chipId);
      const fd = !!state.chipFaceDown?.[chipId];

      chipUid++;
      const el = document.createElement('div');
      el.className = 'owned-chip draggable';
      el.dataset.chipId = chipId;
      el.innerHTML = chipSVG(color, stars, chipUid, fd);

      el.addEventListener('pointerdown', (e) => startOwnedChipDrag(e, chipId), { passive:false });
      box.appendChild(el);
    });
  });

  requestAnimationFrame(updateOwnCircleToFit);
}

async function claimChip(chipId){
  if (!state.roomCode) return false;
  const oneRef = ref(db, `rooms/${state.roomCode}/chipOwners/${chipId}`);
  const snap = await get(oneRef);
  if (snap.exists() && snap.val()) return false;

  await set(oneRef, state.userId);
  return true;
}

async function toggleChipFaceDown(chipId){
  if (!state.roomCode) return;
  if (state.chipOwners && state.chipOwners[chipId]) return;
  const cur = !!state.chipFaceDown?.[chipId];
  try{
    await set(ref(db, `rooms/${state.roomCode}/chipFaceDown/${chipId}`), !cur);
  }catch(e){}
}

/* =========================
   ★ チッププール位置同期
   ========================= */
let chipPosCommitTimer = 0;
function scheduleCommitChipPoolPos(){
  if (!state.roomCode) return;
  if (chipPosCommitTimer) return;
  chipPosCommitTimer = setTimeout(() => {
    chipPosCommitTimer = 0;
    commitChipPoolPosAll();
  }, 80);
}
async function commitChipPoolPosAll(){
  if (!state.roomCode) return;
  if (!chipState.chips.length) return;

  const rect = chipPoolArea.getBoundingClientRect();
  const d = getChipD();
  const W = rect.width, H = rect.height;

  const payload = {};
  chipState.chips.forEach(ch => {
    if (state.chipOwners && state.chipOwners[ch.id]) return;
    payload[ch.id] = {
      x: clamp(Math.round(ch.x), 0, Math.max(0, W - d)),
      y: clamp(Math.round(ch.y), 0, Math.max(0, H - d)),
      updatedAt: Date.now(),
      updatedBy: state.userId
    };
  });

  try{
    await update(ref(db, `rooms/${state.roomCode}/chipPoolPos`), payload);
  }catch(e){}
}
function applyChipPoolPosFromState(){
  if (!chipState.chips.length) return;

  const pos = state.chipPoolPos || {};
  const rect = chipPoolArea.getBoundingClientRect();
  const d = getChipD();
  const W = rect.width, H = rect.height;

  chipState.chips.forEach(ch => {
    const p = pos[ch.id];
    if (!p) return;
    if (chipState.draggingId === ch.id) return;

    const nx = clamp(Number(p.x), 0, Math.max(0, W - d));
    const ny = clamp(Number(p.y), 0, Math.max(0, H - d));
    if (!Number.isFinite(nx) || !Number.isFinite(ny)) return;

    ch.x = nx; ch.y = ny;
    attachChipToPool(ch);
    applyChipTransform(ch);
  });
}

/* =========================
   ★ プール内「押し出し」処理
   ========================= */
function resolveOverlaps(draggingId){
  const d = getChipD();
  const r = d / 2;

  const rect = chipPoolArea.getBoundingClientRect();
  const W = rect.width;
  const H = rect.height;

  const iters = 4;
  for (let t=0; t<iters; t++){
    for (let i=0; i<chipState.chips.length; i++){
      const a = chipState.chips[i];
      for (let j=i+1; j<chipState.chips.length; j++){
        const b = chipState.chips[j];

        if ((state.chipOwners && state.chipOwners[a.id]) || (state.chipOwners && state.chipOwners[b.id])) continue;

        const aIsDrag = (a.id === draggingId);
        const bIsDrag = (b.id === draggingId);

        let ax = a.x + r, ay = a.y + r;
        let bx = b.x + r, by = b.y + r;

        let dx = bx - ax;
        let dy = by - ay;

        let dist = Math.hypot(dx, dy);
        const minDist = d;

        if (dist === 0){
          dx = (Math.random() - 0.5) * 0.01;
          dy = (Math.random() - 0.5) * 0.01;
          dist = Math.hypot(dx, dy);
        }

        if (dist < minDist){
          const overlap = (minDist - dist);
          const nx = dx / dist;
          const ny = dy / dist;

          const pushA = bIsDrag ? overlap : (aIsDrag ? 0 : overlap/2);
          const pushB = aIsDrag ? overlap : (bIsDrag ? 0 : overlap/2);

          if (pushA){
            a.x -= nx * pushA;
            a.y -= ny * pushA;
          }
          if (pushB){
            b.x += nx * pushB;
            b.y += ny * pushB;
          }

          a.x = clamp(a.x, 0, W - d);
          a.y = clamp(a.y, 0, H - d);
          b.x = clamp(b.x, 0, W - d);
          b.y = clamp(b.y, 0, H - d);
        }
      }
    }
  }
}

/* =========================================================
   ★ ダブルクリックで裏返す
   ========================================================= */
function startChipDragNow(ch, rectArea){
  chipState.draggingId = ch.id;
  ch.el.classList.add('dragging');
  attachChipToDragLayer(ch);

  ch.el.style.left = `${rectArea.left + ch.x}px`;
  ch.el.style.top  = `${rectArea.top  + ch.y}px`;
}

function onChipPointerDown(e, chipId){
  e.preventDefault();
  e.stopPropagation();

  if (state.chipOwners && state.chipOwners[chipId]) return;

  const ch = getChipById(chipId);
  if (!ch || !ch.el) return;

  const rectArea = chipPoolArea.getBoundingClientRect();

  const chipLeftInView = rectArea.left + ch.x;
  const chipTopInView  = rectArea.top  + ch.y;
  const offX = e.clientX - chipLeftInView;
  const offY = e.clientY - chipTopInView;

  chipState.dragMeta[chipId] = {
    startX: ch.x,
    startY: ch.y,
    lastWallPos: { x: ch.x, y: ch.y }
  };

  chipState.press = {
    chipId,
    pointerId: e.pointerId,
    downX: e.clientX,
    downY: e.clientY,
    startedDrag: false,
    offX, offY
  };

  const onMove = (ev) => onChipPointerMove(ev);
  const onUp   = (ev) => onChipPointerUp(ev, onMove, onUp);

  window.addEventListener('pointermove', onMove, { passive:false });
  window.addEventListener('pointerup', onUp, { passive:false });
  window.addEventListener('pointercancel', onUp, { passive:false });
}

function onChipPointerMove(e){
  if (!chipState.press) return;

  e.preventDefault();

  const { chipId, downX, downY } = chipState.press;
  const ch = getChipById(chipId);
  if (!ch || !ch.el) return;

  const rectArea = chipPoolArea.getBoundingClientRect();
  const d = getChipD();
  const W = rectArea.width;
  const H = rectArea.height;

  const mx = e.clientX;
  const my = e.clientY;

  if (!chipState.press.startedDrag){
    const dist = Math.hypot(mx - downX, my - downY);
    if (dist >= DRAG_START_PX){
      chipState.press.startedDrag = true;
      startChipDragNow(ch, rectArea);
    } else {
      return;
    }
  }

  const inPool = isPointInRect(mx, my, rectArea);

  if (inPool){
    const px = mx - rectArea.left - chipState.press.offX;
    const py = my - rectArea.top  - chipState.press.offY;

    ch.x = clamp(px, 0, W - d);
    ch.y = clamp(py, 0, H - d);

    const inset = 2;
    const distL = ch.x;
    const distR = (W - d) - ch.x;
    const distT = ch.y;
    const distB = (H - d) - ch.y;
    const min = Math.min(distL, distR, distT, distB);

    let backX = ch.x, backY = ch.y;
    if (min === distL) backX = inset;
    else if (min === distR) backX = (W - d) - inset;
    else if (min === distT) backY = inset;
    else backY = (H - d) - inset;

    chipState.dragMeta[ch.id].lastWallPos = { x: clamp(backX,0,W-d), y: clamp(backY,0,H-d) };

    resolveOverlaps(ch.id);
    chipState.chips.forEach(c => {
      if (c.id !== ch.id) applyChipTransform(c);
    });

    ch.el.style.left = `${rectArea.left + ch.x}px`;
    ch.el.style.top  = `${rectArea.top  + ch.y}px`;

    scheduleCommitChipPoolPos();
  } else {
    const left = mx - chipState.press.offX;
    const top  = my - chipState.press.offY;
    ch.el.style.left = `${left}px`;
    ch.el.style.top  = `${top}px`;
  }
}

async function onChipPointerUp(e, onMove, onUp){
  if (!chipState.press) return;
  e.preventDefault();

  const press = chipState.press;
  chipState.press = null;

  window.removeEventListener('pointermove', onMove);
  window.removeEventListener('pointerup', onUp);
  window.removeEventListener('pointercancel', onUp);

  const chipId = press.chipId;
  const ch = getChipById(chipId);
  if (!ch || !ch.el) return;

  const rectArea = chipPoolArea.getBoundingClientRect();

  if (!press.startedDrag){
    const inPool = isPointInRect(e.clientX, e.clientY, rectArea);
    if (!inPool) return;

    const moved = Math.hypot(e.clientX - press.downX, e.clientY - press.downY);
    if (moved > 6) return;

    const last = chipState.lastTap[chipId];
    const now = Date.now();

    if (last && (now - last.at) <= 320){
      delete chipState.lastTap[chipId];
      await toggleChipFaceDown(chipId);
    } else {
      chipState.lastTap[chipId] = { at: now, x: e.clientX, y: e.clientY };
      setTimeout(() => {
        const cur = chipState.lastTap[chipId];
        if (cur && (Date.now() - cur.at) > 320) delete chipState.lastTap[chipId];
      }, 350);
    }
    return;
  }

  chipState.draggingId = null;
  ch.el.classList.remove('dragging');

  const d = getChipD();
  const left = Number(String(ch.el.style.left || '0').replace('px','')) || 0;
  const top  = Number(String(ch.el.style.top  || '0').replace('px','')) || 0;
  const cx = left + d/2;
  const cy = top  + d/2;

  const droppedInPool = isPointInRect(cx, cy, rectArea);
  const droppedInOwn = isPointInOwnCircle(cx, cy);

  if (droppedInOwn){
    const ok = await claimChip(ch.id);
    if (ok){
      const meta = chipState.dragMeta[ch.id] || { startX: ch.x, startY: ch.y };
      ch.x = meta.startX; ch.y = meta.startY;
      attachChipToPool(ch);
      ch.el.style.display = 'none';
      chipState.dragMeta[ch.id] = null;

      state.chipOwners = { ...(state.chipOwners||{}), [ch.id]: state.userId };
      applyChipOwnersToPool();
      renderOwnedChips();
      updateOwnCircleToFit();
      return;
    }
  }

  if (droppedInPool){
    const px = cx - rectArea.left - d/2;
    const py = cy - rectArea.top  - d/2;
    ch.x = clamp(px, 0, rectArea.width - d);
    ch.y = clamp(py, 0, rectArea.height - d);

    attachChipToPool(ch);
    resolveOverlaps(null);
    chipState.chips.forEach(applyChipTransform);
    chipState.dragMeta[ch.id] = null;

    scheduleCommitChipPoolPos();
    return;
  }

  const meta = chipState.dragMeta[ch.id] || {};
  const back = meta.lastWallPos || { x: meta.startX ?? ch.x, y: meta.startY ?? ch.y };
  ch.x = back.x;
  ch.y = back.y;

  attachChipToPool(ch);
  resolveOverlaps(null);
  chipState.chips.forEach(applyChipTransform);

  chipState.dragMeta[ch.id] = null;
  scheduleCommitChipPoolPos();
}

/* =========================
   ★ チッププール描画
   ========================= */
function renderChipPool(playerCount){
  if (joinBox.classList.contains('hidden')) chipPool.classList.remove('hidden');

  setChipDFromTag();

  const n = Math.max(0, Number(playerCount || 0));

  if (!n){
    chipPoolArea.innerHTML = '';
    chipPool.style.width = '';
    chipPool.style.height = '';
    chipState = { ...chipState, builtFor: null, chips: [], draggingId: null, dragMeta:{}, press:null, lastTap:{} };
    return;
  }

  /* ：人数に応じてプールサイズを更新（先にサイズ確定→rect計測が安定） */
  resizeChipPoolForPlayers(n);

  const needRebuild = (chipState.builtFor !== n);
  if (!needRebuild && chipState.chips.length){
    applyChipPoolPosFromState();

    const hasAnyPos = state.chipPoolPos && Object.keys(state.chipPoolPos).length > 0;
    if (!hasAnyPos){
      layoutChipPositions(chipState.chips);
      chipState.chips.forEach(ch => {
        if (ch.id !== chipState.draggingId) applyChipTransform(ch);
      });
      resolveOverlaps(null);
      chipState.chips.forEach(ch => {
        if (ch.id !== chipState.draggingId) applyChipTransform(ch);
      });
      if (state.isHost) scheduleCommitChipPoolPos();
    }

    applyChipOwnersToPool();
    applyChipFacesToPool();
    return;
  }

  chipState.builtFor = n;
  chipState.draggingId = null;
  chipState.dragMeta = {};
  chipState.press = null;
  chipState.lastTap = {};
  chipPoolArea.innerHTML = '';

  const chips = buildChipSetForPlayers(n);

  const hasAnyPos = state.chipPoolPos && Object.keys(state.chipPoolPos).length > 0;

  if (hasAnyPos){
    const rect = chipPoolArea.getBoundingClientRect();
    const d = getChipD();
    const W = rect.width, H = rect.height;
    chips.forEach(ch => {
      const p = state.chipPoolPos[ch.id];
      if (p && Number.isFinite(Number(p.x)) && Number.isFinite(Number(p.y))){
        ch.x = clamp(Number(p.x), 0, Math.max(0, W - d));
        ch.y = clamp(Number(p.y), 0, Math.max(0, H - d));
      }
    });
    const missing = chips.filter(ch => !state.chipPoolPos[ch.id]);
    if (missing.length){
      layoutChipPositions(missing);
    }
  } else {
    layoutChipPositions(chips);
  }

  chips.forEach(ch => {
    chipUid++;
    const el = document.createElement('div');
    el.className = 'chip-item';
    el.dataset.chipId = ch.id;

    ch.faceDown = !!state.chipFaceDown?.[ch.id];
    el.innerHTML = chipSVG(ch.color, ch.stars, chipUid, ch.faceDown);

    ch.el = el;
    applyChipTransform(ch);

    el.addEventListener('pointerdown', (e) => onChipPointerDown(e, ch.id), { passive:false });

    chipPoolArea.appendChild(el);
  });

  chipState.chips = chips;

  if (!hasAnyPos){
    resolveOverlaps(null);
    chipState.chips.forEach(applyChipTransform);
    if (state.isHost) scheduleCommitChipPoolPos();
  }

  applyChipOwnersToPool();
  applyChipFacesToPool();
}

async function hostStartGameWithDealCount(dealCount = 2){
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const cnt = Math.max(1, Math.floor(Number(dealCount || 2)));

  // 配布順：現在認識しているプレイヤー（既存の start と同じ前提）
  const order = (latestPlayers || []).map(p => p.id).filter(Boolean);
  if (!order.length) return;

  // デッキ生成＆シャッフル
  const deck = shuffleInPlace(buildDeck52());

  // 各プレイヤーにcnt枚配布
  const patch = {};
  for (const pid of order){
    const cards = deck.splice(0, cnt);
    patch[`hands/${pid}/cards`] = cards;
  }

  // game本体（既存のスタートと同等：board0枚、deck残り、dealでアニメ同期）
  const dealId = Date.now();
  patch[`game/started`] = true;
  patch[`game/deck`] = deck;
  patch[`game/boardCodes`] = [];
  patch[`game/boardFaceUpCount`] = 0;
  patch[`game/deal`] = { id: dealId, at: dealId, order, count: cnt };

  await update(ref(db, `rooms/${state.roomCode}`), patch);
}


/* =========================
   ★ 52枚デッキ・カード
   ========================= */
function buildDeck52(){
  const suits = [{ s: "♠" },{ s: "♥" },{ s: "♦" },{ s: "♣" }];
  const ranks = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const deck = [];
  for (const su of suits){
    for (const r of ranks) deck.push(`${su.s}${r}`);
  }
  return deck;
}
function shuffleInPlace(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function parseCard(code){
  if (!code || typeof code !== 'string') return null;
  if (code === 'J_'){
    return { suit: '', rank: 'J', isRed: false, isSuitless: true };
  }
  const suit = code.slice(0,1);
  const rank = code.slice(1);
  const isRed = (suit === '♥' || suit === '♦');
  return { suit, rank, isRed };
}
function pipToPercent(row, col){
  const rows = 5, cols = 3;
  const x = (col + 0.5) / cols * 100;
  const y = (row + 0.5) / rows * 100;
  return { x, y };
}
const PIP_LAYOUT = {
  2: [[0,1],[4,1]],
  3: [[0,1],[2,1],[4,1]],
  4: [[0,0],[0,2],[4,0],[4,2]],
  5: [[0,0],[0,2],[2,1],[4,0],[4,2]],
  6: [[0,0],[0,2],[2,0],[2,2],[4,0],[4,2]],
  7: [[0,0],[0,2],[1,1],[2,0],[2,2],[4,0],[4,2]],
  8: [[0,0],[0,2],[1,1],[2,0],[2,2],[3,1],[4,0],[4,2]],
  9: [[0,0],[0,2],[1,0],[1,2],[2,1],[3,0],[3,2],[4,0],[4,2]],
  10:[[0,0],[0,2],[1,1],[1,0],[1,2],[3,0],[3,2],[3,1],[4,0],[4,2]]
};
function createCardElement(code){
  const c = parseCard(code);
  if (!c) return document.createElement('div');

  const el = document.createElement('div');
  el.className = `pcard ${c.isRed ? 'red' : 'black'}`;
  el.dataset.rank = c.rank;
  el.dataset.suit = c.suit;
  el.dataset.code = String(code);

  const cornerTL = document.createElement('div');
  cornerTL.className = 'corner tl';
  cornerTL.innerHTML = `<div class="rank">${c.rank}</div><div class="suit">${c.suit}</div>`;

  const cornerBR = document.createElement('div');
  cornerBR.className = 'corner br';
  cornerBR.innerHTML = `<div class="rank">${c.rank}</div><div class="suit">${c.suit}</div>`;

  el.appendChild(cornerTL);
  el.appendChild(cornerBR);

  const rankNum = (c.rank === 'A') ? 1 : Number(c.rank);
  const isFace = (c.rank === 'J' || c.rank === 'Q' || c.rank === 'K');

  const pips = document.createElement('div');
  pips.className = 'pips';

  if (isFace){
    // 絵札の場合
    const suitCode = {
      '♥': 'H',
      '♦': 'D', 
      '♠': 'S',
      '♣': 'C'
    }[c.suit];
    
    const rankCode = {
      'J': '11',
      'Q': '12',
      'K': '13'
    }[c.rank];
    
    if (suitCode && rankCode) {
      // 画像ファイル名（例: H11.jpg, S13.jpg）
      const imgFileName = `${suitCode}${rankCode}.jpg`;
      
      // 画像を表示する要素を作成
      const imgContainer = document.createElement('div');
      imgContainer.className = 'face-image-container';
      imgContainer.style.position = 'absolute';
      imgContainer.style.top = '14px';
      imgContainer.style.left = '10px';
      imgContainer.style.right = '10px';
      imgContainer.style.bottom = '14px';
      imgContainer.style.borderRadius = '8px';
      imgContainer.style.overflow = 'hidden';
      imgContainer.style.display = 'flex';
      imgContainer.style.alignItems = 'center';
      imgContainer.style.justifyContent = 'center';
            imgContainer.style.zIndex = '1'; // 画像を背面に


      const img = document.createElement('img');
      img.src = imgFileName;
      img.alt = `${c.rank} of ${c.suit}`;
      img.style.width = '100%';
      img.style.height = '100%';
      img.style.objectFit = 'contain';
      img.style.objectPosition = 'center';
      
      // 画像読み込みエラー時のフォールバック
      img.onerror = function() {
        // 画像が読み込めない場合はテキスト表示に戻す
        imgContainer.innerHTML = '';
        const face = document.createElement('div');
        face.className = 'face-holder';
        face.textContent = c.rank;
        face.style.position = 'absolute';
        face.style.inset = '0';
        face.style.display = 'flex';
        face.style.alignItems = 'center';
        face.style.justifyContent = 'center';
        face.style.fontWeight = '1000';
        face.style.fontSize = '28px';
        face.style.opacity = '0.20';
        face.style.letterSpacing = '0.02em';
        
        const fs = document.createElement('div');
        fs.className = 'face-suit';
        fs.textContent = c.suit;
        fs.style.position = 'absolute';
        fs.style.left = '50%';
        fs.style.top = '52%';
        fs.style.transform = 'translate(-50%, -50%)';
        fs.style.fontSize = '22px';
        fs.style.opacity = '0.35';
        fs.style.fontWeight = '900';
        
        imgContainer.appendChild(face);
        imgContainer.appendChild(fs);
      };
      
      imgContainer.appendChild(img);
      el.appendChild(imgContainer);
    } else {
      // 通常のテキスト表示（フォールバック）
      const face = document.createElement('div');
      face.className = 'face-holder';
      face.textContent = c.rank;

      const fs = document.createElement('div');
      fs.className = 'face-suit';
      fs.textContent = c.suit;

      el.appendChild(face);
      el.appendChild(fs);
    }
  } else {
    // 数字カードの処理（既存のまま）
    if (c.rank === 'A'){
      const {x,y} = pipToPercent(2,1);
      const pip = document.createElement('div');
      pip.className = 'pip';
      pip.style.left = `${x}%`;
      pip.style.top  = `${y}%`;
      pip.textContent = c.suit;
      pips.appendChild(pip);
    } else {
      const layout = PIP_LAYOUT[rankNum] || [];
      layout.forEach(([r, col]) => {
        const {x,y} = pipToPercent(r,col);
        const pip = document.createElement('div');
        pip.className = 'pip' + (r >= 3 ? ' flip' : '');
        pip.style.left = `${x}%`;
        pip.style.top  = `${y}%`;
        pip.textContent = c.suit;
        pips.appendChild(pip);
      });
    }
    el.appendChild(pips);
  }
  return el;
}
function createBackCardElement(){
  const el = document.createElement('div');
  el.className = 'backcard';
  return el;
}

/* =========================================================
   ：ポーカー役判定（7枚→最強5枚）
   - 5枚組み合わせ全探索（最大21通り）
   - 英語役名 + タイブレーク
   ========================================================= */
const RANK_VALUE = {
  "2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"J":11,"Q":12,"K":13,"A":14
};
function cardToEval(code){
  const c = parseCard(code);
  if (!c) return null;
  const v = RANK_VALUE[c.rank];
  return { code, suit:c.suit, rank:c.rank, v: Number(v) };
}
function cmpLex(a, b){
  const n = Math.max(a.length, b.length);
  for (let i=0;i<n;i++){
    const x = a[i] ?? 0;
    const y = b[i] ?? 0;
    if (x !== y) return x - y;
  }
  return 0;
}
function choose5(list){
  const res = [];
  const n = list.length;
  for (let a=0; a<n-4; a++){
    for (let b=a+1; b<n-3; b++){
      for (let c=b+1; c<n-2; c++){
        for (let d=c+1; d<n-1; d++){
          for (let e=d+1; e<n; e++){
            res.push([list[a],list[b],list[c],list[d],list[e]]);
          }
        }
      }
    }
  }
  return res;
}
function straightHighFromValues(valsDesc){
  // valsDesc: unique values sorted desc
  if (valsDesc.length < 5) return 0;
  // normal
  for (let i=0; i<=valsDesc.length-5; i++){
    const slice = valsDesc.slice(i, i+5);
    let ok = true;
    for (let j=0;j<4;j++){
      if (slice[j] - 1 !== slice[j+1]) { ok=false; break; }
    }
    if (ok) return slice[0];
  }
  // wheel A-5
  const set = new Set(valsDesc);
  if (set.has(14) && set.has(5) && set.has(4) && set.has(3) && set.has(2)) return 5;
  return 0;
}
function eval5(cards5){
  // cards5: [{code,suit,v,rank}...]
  const suits = cards5.map(c=>c.suit);
  const vals = cards5.map(c=>c.v).sort((a,b)=>b-a);
  const isFlush = suits.every(s => s === suits[0]);

  const uniqValsDesc = Array.from(new Set(vals)).sort((a,b)=>b-a);
  const sh = straightHighFromValues(uniqValsDesc);
  const isStraight = sh > 0;

  const counts = {};
  for (const v of vals) counts[v] = (counts[v]||0)+1;

  const groups = Object.entries(counts)
    .map(([v,c]) => ({ v:Number(v), c:Number(c) }))
    .sort((a,b)=> (b.c - a.c) || (b.v - a.v));

  // Straight Flush (+ Royal)
  if (isFlush && isStraight){
    if (sh === 14 && uniqValsDesc.includes(10)){
      return { cat: 8, score:[8,14], name:"ROYAL FLUSH" };
    }
    return { cat: 8, score:[8, sh], name:"STRAIGHT FLUSH" };
  }

  // Four of a Kind
  if (groups[0]?.c === 4){
    const quad = groups[0].v;
    const kicker = groups.find(g=>g.c===1)?.v ?? 0;
    return { cat: 7, score:[7, quad, kicker], name:"FOUR OF A KIND" };
  }

  // Full House
  if (groups[0]?.c === 3 && groups[1]?.c === 2){
    const tri = groups[0].v;
    const pair = groups[1].v;
    return { cat: 6, score:[6, tri, pair], name:"FULL HOUSE" };
  }

  // Flush
  if (isFlush){
    return { cat: 5, score:[5, ...vals], name:"FLUSH" };
  }

  // Straight
  if (isStraight){
    return { cat: 4, score:[4, sh], name:"STRAIGHT" };
  }

  // Three of a Kind
  if (groups[0]?.c === 3){
    const tri = groups[0].v;
    const kickers = groups.filter(g=>g.c===1).map(g=>g.v).sort((a,b)=>b-a);
    return { cat: 3, score:[3, tri, ...kickers], name:"THREE OF A KIND" };
  }

  // Two Pair
  if (groups[0]?.c === 2 && groups[1]?.c === 2){
    const p1 = Math.max(groups[0].v, groups[1].v);
    const p2 = Math.min(groups[0].v, groups[1].v);
    const kicker = groups.find(g=>g.c===1)?.v ?? 0;
    return { cat: 2, score:[2, p1, p2, kicker], name:"TWO PAIR" };
  }

  // One Pair
  if (groups[0]?.c === 2){
    const pair = groups[0].v;
    const kickers = groups.filter(g=>g.c===1).map(g=>g.v).sort((a,b)=>b-a);
    return { cat: 1, score:[1, pair, ...kickers], name:"ONE PAIR" };
  }

  // High Card
  return { cat: 0, score:[0, ...vals], name:"HIGH CARD" };
}
function bestHandFromCodes(codes){
  const cards = (codes||[]).map(cardToEval).filter(Boolean);
  if (cards.length < 5) return null;
  let best = null;
  let bestCombo = null;

  const combos = choose5(cards);
  for (const combo of combos){
    const e = eval5(combo);
    if (!best){
      best = e; bestCombo = combo;
      continue;
    }
    if (cmpLex(e.score, best.score) > 0){
      best = e; bestCombo = combo;
    }
  }

  if (!best || !bestCombo) return null;
  const bestFiveCodes = bestCombo.map(c=>c.code);
  const ordered = orderBestFiveForDisplay(bestCombo, best);
  return { name: best.name, score: best.score, bestFiveCodes, displayCodes: ordered };
}
function orderBestFiveForDisplay(cards5, bestEval){
  if (!cards5 || cards5.length !== 5 || !bestEval) return (cards5 || []).map(c=>c.code);

  const byValue = new Map();
  cards5.forEach(card => {
    if (!byValue.has(card.v)) byValue.set(card.v, []);
    byValue.get(card.v).push(card);
  });

  const counts = {};
  cards5.forEach(c => counts[c.v] = (counts[c.v] || 0) + 1);
  const groups = Object.entries(counts)
    .map(([v,c]) => ({ v:Number(v), c:Number(c) }))
    .sort((a,b)=> (b.c - a.c) || (b.v - a.v));

  const pullAll = (v) => {
    const arr = byValue.get(v) || [];
    byValue.set(v, []);
    return arr;
  };
  const pullOne = (v) => {
    const arr = byValue.get(v) || [];
    const card = arr.shift();
    if (arr.length === 0) byValue.delete(v);
    else byValue.set(v, arr);
    return card;
  };

  const orderedCards = [];
  const cat = bestEval.cat ?? bestEval.score?.[0] ?? 0;

  if (cat === 8 || cat === 4){
    const sh = bestEval.score?.[1] ?? 0;
    const seq = (sh === 5)
      ? [5,4,3,2,14]
      : [sh, sh-1, sh-2, sh-3, sh-4];
    seq.forEach(v => {
      const card = pullOne(v);
      if (card) orderedCards.push(card);
    });
  } else if (cat === 7){
    const quad = groups[0]?.v;
    const kicker = groups.find(g=>g.c===1)?.v;
    if (quad) orderedCards.push(...pullAll(quad));
    if (kicker) orderedCards.push(...pullAll(kicker));
  } else if (cat === 6){
    const tri = groups[0]?.v;
    const pair = groups[1]?.v;
    if (tri) orderedCards.push(...pullAll(tri));
    if (pair) orderedCards.push(...pullAll(pair));
  } else if (cat === 3){
    const tri = groups[0]?.v;
    if (tri) orderedCards.push(...pullAll(tri));
    const kickers = groups.filter(g=>g.c===1).map(g=>g.v).sort((a,b)=>b-a);
    kickers.forEach(v => orderedCards.push(...pullAll(v)));
  } else if (cat === 2){
    const pairHigh = Math.max(groups[0]?.v ?? 0, groups[1]?.v ?? 0);
    const pairLow = Math.min(groups[0]?.v ?? 0, groups[1]?.v ?? 0);
    if (pairHigh) orderedCards.push(...pullAll(pairHigh));
    if (pairLow) orderedCards.push(...pullAll(pairLow));
    const kicker = groups.find(g=>g.c===1)?.v;
    if (kicker) orderedCards.push(...pullAll(kicker));
  } else if (cat === 1){
    const pair = groups[0]?.v;
    if (pair) orderedCards.push(...pullAll(pair));
    const kickers = groups.filter(g=>g.c===1).map(g=>g.v).sort((a,b)=>b-a);
    kickers.forEach(v => orderedCards.push(...pullAll(v)));
  } else {
    orderedCards.push(...cards5.slice().sort((a,b)=>b.v - a.v));
  }

  const orderedCodes = orderedCards.map(c=>c.code);
  if (orderedCodes.length !== 5){
    return cards5.slice().sort((a,b)=>b.v - a.v).map(c=>c.code);
  }
  return orderedCodes;
}



function getPlayerName(pid){
  const p = latestPlayers.find(x => x.id === pid);
  return p ? (p.name || 'PLAYER') : 'PLAYER';
}
function showHandResultPop(playerName, handName, bestFiveCodes){
  if (state._handPopTimer) clearTimeout(state._handPopTimer);
  handResultTitle.textContent = String(handName || 'HAND');
  handResultSub.textContent = String(playerName || 'PLAYER');

  handResultCards.innerHTML = '';
  (bestFiveCodes || []).forEach(code => {
    const el = createCardElement(code);
    handResultCards.appendChild(el);
  });

  // animationを確実にリトリガー
  handResultPop.classList.remove('hidden');
  const old = handResultCard.style.animation;
  handResultCard.style.animation = 'none';
  // reflow
  void handResultCard.offsetWidth;
  handResultCard.style.animation = old || 'handPop 5.0s cubic-bezier(.22,.84,.44,1) both';

  state._handPopTimer = setTimeout(() => {
    handResultPop.classList.add('hidden');
  }, 5000);
}
function maybeShowRevealHandPop(){
  const r = state.reveal;
  const revealed = r?.revealed || {};
  // 初回購読は「既に公開済み」があっても出さない
  if (!state._revealPopInited){
    state._revealPopInited = true;
    state._prevRevealed = { ...revealed };
    return;
  }

  const prev = state._prevRevealed || {};
  const newly = [];
  for (const [pid, v] of Object.entries(revealed)){
    if (!v) continue;
    if (!prev[pid]) newly.push(pid);
  }
  state._prevRevealed = { ...revealed };

  if (!newly.length) return;

  // ふつうは1人ずつだが念のため最後を表示
  const pid = newly[newly.length - 1];

  // 場5枚 + 手札（最大2枚想定）
  const board = getBoardCodes().slice(0,5);
  const hand = (state.hands?.[pid]?.cards && Array.isArray(state.hands[pid].cards)) ? state.hands[pid].cards : [];
  const pool = [...board, ...hand].filter(Boolean);

  const best = bestHandFromCodes(pool);
  if (!best) return;

  const displayCodes = best.displayCodes || best.bestFiveCodes;
  showHandResultPop(getPlayerName(pid), best.name, displayCodes);
}

/* =========================
   ★ デッキ表示
   ========================= */
const STACK_MAX = 15;
const STACK_OFFSETS = [
  {x:0.0,y:0.0,r: 0.0},{x:0.4,y:0.5,r:-0.3},{x:0.9,y:0.9,r: 0.2},{x:1.2,y:1.5,r:-0.4},
  {x:1.8,y:1.9,r: 0.5},{x:2.2,y:2.5,r:-0.2},{x:2.8,y:2.9,r: 0.4},{x:3.1,y:3.6,r:-0.6},
  {x:3.7,y:4.0,r: 0.3},{x:4.2,y:4.6,r:-0.3},{x:4.8,y:5.0,r: 0.6},{x:5.2,y:5.7,r:-0.4},
  {x:5.8,y:6.1,r: 0.4},{x:6.2,y:6.8,r:-0.2},{x:6.8,y:7.2,r: 0.2},
];
function calcStackLayers(deckLen){
  const removed = 52 - deckLen;
  const layers = STACK_MAX - Math.floor(removed / 2);
  return Math.max(1, Math.min(STACK_MAX, layers));
}
function renderDeckVisual(deckStackEl, deckLen, started){
  const shownLen = started ? deckLen : 52;

  deckStackEl.classList.toggle('empty', started && shownLen === 0);

  const countEl = deckStackEl.querySelector('#deckCount');
  deckStackEl.querySelectorAll('.deck-layer').forEach(n => n.remove());

  const layers = (started && shownLen === 0) ? 0 : calcStackLayers(shownLen);
  for (let i = layers - 1; i >= 0; i--){
    const layer = document.createElement('div');
    layer.className = 'deck-layer';
    const o = STACK_OFFSETS[i] || {x:0,y:0,r:0};
    layer.style.transform = `translate(${o.x}px, ${o.y}px) rotate(${o.r}deg)`;
    deckStackEl.insertBefore(layer, countEl);
  }

  if (countEl) countEl.textContent = String(shownLen);
}

function getBoardCodes(){
  const g = state.game || {};
  const codes = Array.isArray(g.boardCodes) ? g.boardCodes : (Array.isArray(g.board) ? g.board : []);
  return codes.filter(Boolean);
}
function getBoardFaceUpCount(){
  const g = state.game || {};
  const n = Number(g.boardFaceUpCount || 0);
  return Number.isFinite(n) ? n : 0;
}
function attachCenterInteractions(){
  const deckStackEl = playerCircle.querySelector('#deckStack');
  if (deckStackEl && !deckStackEl.dataset.bound){
    deckStackEl.dataset.bound = '1';
    deckStackEl.addEventListener('click', onDeckClick);
  }
  const boardRowEl = playerCircle.querySelector('#boardRow');
  if (boardRowEl && !boardRowEl.dataset.bound){
    boardRowEl.dataset.bound = '1';
    boardRowEl.addEventListener('click', onBoardClick);
  }
}
function renderCenterBoard(){
  const deckStackEl = playerCircle.querySelector('#deckStack');
  const boardRowEl  = playerCircle.querySelector('#boardRow');
  if (!deckStackEl || !boardRowEl) return;

  attachCenterInteractions();

  const started = !!state.game?.started;
  const deck = Array.isArray(state.game?.deck) ? state.game.deck : [];
  const boardCodes = started ? getBoardCodes() : [];
  const faceUpCount = started ? Math.min(getBoardFaceUpCount(), boardCodes.length) : 0;

  renderDeckVisual(deckStackEl, started ? deck.length : 52, started);

  const slots = boardRowEl.querySelectorAll('.board-slot');
  slots.forEach((slot, i) => {
    slot.innerHTML = '';
    slot.classList.remove('has-card');

    if (!started) return;

    if (i < boardCodes.length){
      slot.classList.add('has-card');
      if (i < faceUpCount){
        const cardEl = createCardElement(boardCodes[i]);
        slot.appendChild(cardEl);
      } else {
        const back = createBackCardElement();
        slot.appendChild(back);
      }
    }
  });
}

/* =========================
   ★ 配布アニメ
   ========================= */
function getDealSeenKey(){
  return state.roomCode ? `dealSeen_${state.roomCode}` : `dealSeen_unknown`;
}
function getShownCount(pid){
  if (state.dealing && state.dealShownCounts && typeof state.dealShownCounts[pid] === 'number'){
    return state.dealShownCounts[pid];
  }
  const handData = state.hands[pid];
  return (handData && Array.isArray(handData.cards)) ? handData.cards.length : 0;
}
async function waitForTags(order){
  for (let i=0; i<40; i++){
    const ok = order.every(pid => document.querySelector(`.player-wrap[data-pid="${pid}"]`));
    if (ok) return true;
    await sleep(50);
  }
  return false;
}
async function animateOneFly(startX, startY, endX, endY, extraRot=0, duration=380){
  const el = document.createElement('div');
  el.className = 'fly-card';
  el.style.left = '0px';
  el.style.top  = '0px';
  document.body.appendChild(el);

  const halfW = 30, halfH = 45;
  const sx = startX - halfW, sy = startY - halfH;
  const ex = endX - halfW,   ey = endY - halfH;
  const mx = (sx + ex) / 2;
  const my = (sy + ey) / 2 - 60;

  const anim = el.animate([
    { transform:`translate(${sx}px, ${sy}px) rotate(${0+extraRot}deg) scale(1)` },
    { transform:`translate(${mx}px, ${my}px) rotate(${2+extraRot}deg) scale(1.02)` },
    { transform:`translate(${ex}px, ${ey}px) rotate(${0+extraRot}deg) scale(1)` },
  ], {
    duration,
    easing: 'cubic-bezier(.22,.84,.44,1)',
    fill: 'forwards'
  });

  await anim.finished.catch(()=>{});
  el.remove();
}
async function runDealAnimation(order, dealCount = 2){
  if (isDealAnimating) return;
  isDealAnimating = true;

  const count = Math.max(0, Math.floor(Number(dealCount || 2)));

  state.dealShownCounts = {};
  order.forEach(pid => state.dealShownCounts[pid] = 0);

  state.dealing = true;
  renderHands();

  try{
    const deckEl = document.getElementById('deckStack');
    if (!deckEl) return;

    const d = deckEl.getBoundingClientRect();
    const startX = d.left + d.width/2;
    const startY = d.top  + d.height/2;

    for (let round=0; round<count; round++){
      for (let i=0; i<order.length; i++){
        const pid = order[i];
        const wrap = document.querySelector(`.player-wrap[data-pid="${pid}"]`);
        if (!wrap) continue;

        const tr = wrap.getBoundingClientRect();
        const endX = tr.left + 10;
        const endY = tr.top + tr.height/2 + 18;

        await animateOneFly(startX, startY, endX, endY, (i%2===0? -1: 1));

        state.dealShownCounts[pid] = (state.dealShownCounts[pid] ?? 0) + 1;
        renderHands();

        await sleep(70);
      }
      await sleep(140);
    }
  } finally {
    state.dealing = false;
    state.dealShownCounts = null;
    isDealAnimating = false;
    renderHands();
  }
}

function getCenterTablePoint(){
  const ct = document.getElementById('centerTable');
  if (!ct) return { x: window.innerWidth/2, y: window.innerHeight/2 };
  const r = ct.getBoundingClientRect();
  return { x: r.left + r.width/2, y: r.top + r.height/2 };
}
function getPlayerPoint(pid){
  const wrap = document.querySelector(`.player-wrap[data-pid="${pid}"]`);
  if (!wrap) return { x: window.innerWidth/2, y: window.innerHeight/2 };
  const r = wrap.getBoundingClientRect();
  return { x: r.left + 10, y: r.top + r.height/2 + 18 };
}


function boardFirst3HasFaceUpJQK(g){
  const board = Array.isArray(g?.boardCodes) ? g.boardCodes : [];
  const faceUp = Number(g?.boardFaceUpCount || 0);
  if (!board.length) return false;
  const maxIndex = Math.min(3, board.length, faceUp);
  for (let i = 0; i < maxIndex; i++){
    const c = parseCard(board[i]);
    if (!c) continue;
    if (c.rank === 'J' || c.rank === 'Q' || c.rank === 'K') return true;
  }
  return false;
}

function getRoundMaxWhiteChipOwner(owners, maxPlayers){
  const count = Math.max(0, Number(maxPlayers || 0));
  if (!owners || !count) return null;
  const chipId = `白_${count}`;
  return owners[chipId] || null;
}


async function triggerC3Effect(){
  if (!state.roomCode) return;

  // 多重発火ガード（直近fxが同種なら無視）
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  const [gSnap, ownersSnap, handsSnap] = await Promise.all([
    get(gameRef),
    get(ref(db, `rooms/${state.roomCode}/chipOwners`)),
    get(ref(db, `rooms/${state.roomCode}/hands`))
  ]);

  const g = gSnap.val() || {};
  if (!g.started) return;
  if (!boardFirst3HasFaceUpJQK(g)) return;
  const fx = g.fx || null;
  if (fx && fx.type === 'C3_REDRAW' && typeof fx.at === 'number' && (Date.now() - fx.at) < 1500){
    return;
  }

  const owners = ownersSnap.val() || {};
  const targetPid = owners["白_1"];
  if (!targetPid) return;

  const hands = handsSnap.val() || {};
  const prevHand = (hands[targetPid]?.cards && Array.isArray(hands[targetPid].cards)) ? hands[targetPid].cards : [];
  const discardCount = prevHand.length;

  const deck = Array.isArray(g.deck) ? [...g.deck] : [];
  if (deck.length < discardCount) return;

  const newCards = deck.splice(0, discardCount);
  const fxId = Date.now();
  const patch = {};
  patch[`hands/${targetPid}/cards`] = newCards;
  patch[`game/deck`] = deck;
  patch[`game/fx`] = { id: fxId, at: fxId, type: 'C3_REDRAW', pid: targetPid, discardCount, drawCount: discardCount };
  await update(ref(db, `rooms/${state.roomCode}`), patch);
}


async function triggerC7Effect(){
  if (!state.roomCode) return;

  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  const [gSnap, ownersSnap, handsSnap] = await Promise.all([
    get(gameRef),
    get(ref(db, `rooms/${state.roomCode}/chipOwners`)),
    get(ref(db, `rooms/${state.roomCode}/hands`))
  ]);
  const roomSnap = await get(ref(db, `rooms/${state.roomCode}`));

  const g = gSnap.val() || {};
  if (!g.started) return;
  if (boardFirst3HasFaceUpJQK(g)) return;

  const fx = g.fx || null;
  if (fx && fx.type === 'C7_REDRAW' && typeof fx.at === 'number' && (Date.now() - fx.at) < 1500){
    return;
  }

  const owners = ownersSnap.val() || {};
 const room = roomSnap.val() || {};
  const targetPid = getRoundMaxWhiteChipOwner(owners, room.maxPlayers || state.room?.maxPlayers);

  if (!targetPid) return;

  const hands = handsSnap.val() || {};
  const prevHand = (hands[targetPid]?.cards && Array.isArray(hands[targetPid].cards)) ? hands[targetPid].cards : [];
  const discardCount = prevHand.length;

  const deck = Array.isArray(g.deck) ? [...g.deck] : [];
  if (deck.length < discardCount) return;

  const newCards = deck.splice(0, discardCount);

  const fxId = Date.now();
  const patch = {};
  patch[`hands/${targetPid}/cards`] = newCards;
  patch[`game/deck`] = deck;
  patch[`game/fx`] = { id: fxId, at: fxId, type: 'C7_REDRAW', pid: targetPid, discardCount, drawCount: discardCount };

  await update(ref(db, `rooms/${state.roomCode}`), patch);
}


function getFxSeenKey(){
  return state.roomCode ? `fxSeen_${state.roomCode}` : 'fxSeen_unknown';
}

let _fxAnimating = false;

async function maybePlayFxFromGame(){
  const fx = state.game?.fx;
  if (!fx || !fx.id || !fx.type) return;

  // 古すぎるのは無視
  if (typeof fx.at === 'number' && (Date.now() - fx.at) > 20000) {
    sessionStorage.setItem(getFxSeenKey(), String(fx.id));
    return;
  }

  const seen = sessionStorage.getItem(getFxSeenKey());
  if (seen === String(fx.id)) return;

  sessionStorage.setItem(getFxSeenKey(), String(fx.id));

  if (fx.type === 'C3_REDRAW' || fx.type === 'C7_REDRAW'){
    if (_fxAnimating) return;
    _fxAnimating = true;
    try{
      const pid = fx.pid;
      setFanHandHiddenForPid(pid, true);
      const discardCount = Math.max(0, Math.floor(Number(fx.discardCount || 0)));
      const drawCount = Math.max(0, Math.floor(Number(fx.drawCount || 2)));

      // 自分が対象なら「捨て→引く」順になるよう一時的に手札を隠す
      const wasHidden = myHandEl.style.visibility === 'hidden';
      if (pid === state.userId) myHandEl.style.visibility = 'hidden';

      const from = getPlayerPoint(pid);
      const center = getCenterTablePoint();

      // 捨てるアニメ（手札枚数分、裏カードが中心へ）
      for (let i=0; i<discardCount; i++){
        await animateOneFly(from.x, from.y, center.x, center.y, (i%2?1:-1));
        await sleep(40);
      }

      await sleep(120);

      // 引きなおしドロー（山札→対象プレイヤー）
      const deckEl = document.getElementById('deckStack');
      const d = deckEl ? deckEl.getBoundingClientRect() : null;
      const startX = d ? (d.left + d.width/2) : (window.innerWidth/2);
      const startY = d ? (d.top  + d.height/2) : (window.innerHeight/2);

      const to = getPlayerPoint(pid);
      for (let i=0; i<drawCount; i++){
        await animateOneFly(startX, startY, to.x, to.y, (i%2?1:-1));
        await sleep(60);
      }

      await sleep(50);
      if (pid === state.userId && !wasHidden) myHandEl.style.visibility = '';
      renderHands();
    } finally {
      setFanHandHiddenForPid(fx.pid, false);
      _fxAnimating = false;
    }
  }
}


async function maybePlayDealFromGame(){
  const started = !!state.game?.started;
  const deal = state.game?.deal;
  if (!started || !deal || !deal.id || !Array.isArray(deal.order)) return;

  const at = typeof deal.at === 'number' ? deal.at : deal.id;
  if (Date.now() - at > 20000) {
    sessionStorage.setItem(getDealSeenKey(), String(deal.id));
    return;
  }

  const seen = sessionStorage.getItem(getDealSeenKey());
  if (seen === String(deal.id)) return;

  sessionStorage.setItem(getDealSeenKey(), String(deal.id));

  const ok = await waitForTags(deal.order);
  if (!ok) return;

const cnt = Number(deal.count || 2);
await runDealAnimation(deal.order, cnt);

}

/* =========================
   ★ 山札/場札クリック（ホスト）
   ========================= */
async function onDeckClick(e){
  e.preventDefault();
  e.stopPropagation();
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  const snap = await get(gameRef);
  const g = snap.val() || { started:false, deck:[], boardCodes:[], boardFaceUpCount:0 };

  if (!g.started) return;

  const deck = Array.isArray(g.deck) ? [...g.deck] : [];
  const boardCodes = Array.isArray(g.boardCodes) ? [...g.boardCodes] : [];
  const faceUpCount = Number(g.boardFaceUpCount || 0);

  if (boardCodes.length === 0){
    if (deck.length < 3) return;
    const drawn = deck.splice(0, 3);
    await update(gameRef, {
      deck,
      boardCodes: drawn,
      boardFaceUpCount: 0
    });
    return;
  }

  const allFaceUp = (faceUpCount >= boardCodes.length);
  if (allFaceUp && boardCodes.length < 5){
    if (deck.length < 1) return;
    const c = deck.shift();
    boardCodes.push(c);
    await update(gameRef, {
      deck,
      boardCodes,
      boardFaceUpCount: boardCodes.length
    });
  }
}
async function onBoardClick(e){
  e.preventDefault();
  e.stopPropagation();
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const slot = e.target.closest('.board-slot');
  if (!slot) return;

  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  const snap = await get(gameRef);
  const g = snap.val() || { started:false, deck:[], boardCodes:[], boardFaceUpCount:0 };

  if (!g.started) return;

  const boardCodes = Array.isArray(g.boardCodes) ? [...g.boardCodes] : [];
  const faceUpCount = Number(g.boardFaceUpCount || 0);

  if (boardCodes.length === 0) return;
  if (faceUpCount >= boardCodes.length) return;

  await update(gameRef, {
    boardFaceUpCount: Math.min(boardCodes.length, faceUpCount + 1)
  });
}

/* =========================
   subscribe
   ========================= */
function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();

    if (joinBox.classList.contains('hidden')){
      const n = Number(state.room.maxPlayers || 0);
      renderChipPool(n);
    }

    if (state.isHost) {
      maybeStartRevealPhaseIfReady();
      ensureSideCardsExistsIfHost();
    }
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();

    if (state.isHost) {
      maybeStartRevealPhaseIfReady();
      ensureSideCardsExistsIfHost();
    }
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  });
}
function subscribeGame(){
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  onValue(gameRef, snap => {
    const v = snap.val();
    const base = { started:false, deck:[], boardCodes:[], boardFaceUpCount:0, deal:null };
    state.game = v ? { ...base, ...v } : base;
    renderCenterBoard();
    maybePlayDealFromGame();
  maybePlayFxFromGame();

  });
}
function subscribeChipOwners(){
  const ownersRef = ref(db, `rooms/${state.roomCode}/chipOwners`);
  onValue(ownersRef, snap => {
    state.chipOwners = snap.val() || {};
    applyChipOwnersToPool();
    renderOwnedChips();
    updateOwnCircleToFit();

    if (state.isHost) maybeStartRevealPhaseIfReady();
  });
}
function subscribeChipPoolPos(){
  const posRef = ref(db, `rooms/${state.roomCode}/chipPoolPos`);
  onValue(posRef, snap => {
    state.chipPoolPos = snap.val() || {};
    applyChipPoolPosFromState();
  });
}
function subscribeChipFaceDown(){
  const fdRef = ref(db, `rooms/${state.roomCode}/chipFaceDown`);
  onValue(fdRef, snap => {
    state.chipFaceDown = snap.val() || {};
    applyChipFacesToPool();
    renderOwnedChips();
  });
}
function subscribeReveal(){
  const rRef = ref(db, `rooms/${state.roomCode}/reveal`);
  onValue(rRef, snap => {
    state.reveal = snap.val() || null;
    renderHands();

    // ：公開された瞬間に「最強5枚＋役」演出（中央2秒）
    maybeShowRevealHandPop();
  });
}

document.addEventListener('dblclick', async (e) => {
  const el = e.target.closest('.ex-float-card');
  if (!el) return;

  // 表示文字 or datasetからカードコード取得（どちらでも動くように）
  const code = (el.dataset.code || el.textContent || '').trim();

  // C10：スタート同等＋3枚配布（スタートと同じくホストのみ）
  if (code === 'C10'){
    e.preventDefault();
    e.stopPropagation();
    if (!state.isHost) return;
    await hostStartGameWithDealCount(3);
    return;
  }

  // C3：条件一致時のみ、白1所持者が捨て→2枚ドロー（誰が押してもOKにしてある）
  if (code === 'C3'){
    e.preventDefault();
    e.stopPropagation();
    await triggerC3Effect();
    return;
  }



  // C7：場1-3枚目に絵札が無い時、最高白チップ所持者が引きなおす
  if (code === 'C7'){
    e.preventDefault();
    e.stopPropagation();
    await triggerC7Effect();
    return;
  }
}, true);


/* =========================
   ★ 手札描画
   ========================= */
function renderMyHand(){
  myHandEl.innerHTML = '';

  const myId = state.userId;
  
  // EXCHANGEステージ中でホールドスナップショットがあればそれを使う
  let finalCards = [];
  if (state.special6?.stage === 'EXCHANGE' && state._special6HoldHandSnap) {
    finalCards = state._special6HoldHandSnap;
  } else {
    const handData = state.hands[myId];
    finalCards = (handData && Array.isArray(handData.cards)) ? handData.cards : [];
  }

  const s6 = state.special6;
  const selection = getSpecial6Selection(myId);
  const selectedIndex = selection ? Number(selection.index) : -1;
  const isSpecial6Active = !!(s6 && s6.active && s6.stage === 'SELECT');
  myHandEl.classList.toggle('special6-pulse', isSpecial6Active && !selection);

  // EXCHANGEステージ中はselectionを無視する（スナップショットには含まれていない）
  const shouldShowSelection = !(state.special6?.stage === 'EXCHANGE');
  const shownCount = getShownCount(myId);

  for (let i=0; i<shownCount; i++){
    if (shouldShowSelection && selection && i === selectedIndex) continue;
    const wrap = document.createElement('div');
    wrap.className = 'my-card';
    wrap.dataset.index = String(i);

    const code = finalCards[i];
    const cardEl = code ? createCardElement(code) : createBackCardElement();
    wrap.appendChild(cardEl);
    myHandEl.appendChild(wrap);
  }

  if (shouldShowSelection && selection && selection.code){
    const picked = document.createElement('div');
    picked.className = 'my-card special6-picked';
    const pickedEl = createCardElement(selection.code);
    picked.appendChild(pickedEl);
    myHandEl.prepend(picked);
  }
}

function renderHands(){
  renderMyHand();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
}

const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeGame();
  subscribeChipOwners();
  subscribeChipPoolPos();
  subscribeChipFaceDown();
  subscribeReveal();

  /* ：左上カード購読 */
  subscribeSideCards();

  syncSeatUI();
  renderCenterBoard();

  chipPool.classList.remove('hidden');
  sideCardsEl.classList.remove('hidden');

  renderChipPool(Number(state.room?.maxPlayers || 0));
  renderSideCards();

  if (state.isHost) await ensureSideCardsExistsIfHost();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='リンクコピー';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');

          renderChipPool(i);
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);

    setChipDFromTag();
    const n = Number(state.room?.maxPlayers || 0);
    if (joinBox.classList.contains('hidden')) renderChipPool(n);
  });
}

function renderPlayerCircle(players){
  playerCircle.innerHTML = '';
  if (!players.length) return;

  const center = document.createElement('div');
  center.className = 'center-table';
  center.id = 'centerTable';
  center.innerHTML = `
    <div id="deckStack" class="deck-stack empty" title="山札">
      <div id="deckCount" class="deck-count">52</div>
    </div>
    <div id="boardRow" class="board-row" aria-label="場札">
      <div class="board-slot" data-slot="0"></div>
      <div class="board-slot" data-slot="1"></div>
      <div class="board-slot" data-slot="2"></div>
      <div class="board-slot" data-slot="3"></div>
      <div class="board-slot" data-slot="4"></div>
    </div>
  `;
  playerCircle.appendChild(center);

  const n = players.length;
  const radius = 45;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  const curRevealPid = getRevealCurrentPid();
  const revealedMap = state.reveal?.revealed || {};

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const wrap = document.createElement('div');
    wrap.className = 'player-wrap';
    if (Math.sin(angle) < -0.6) {
      wrap.classList.add('top-seat');
    }
    wrap.style.left = `${x}%`;
    wrap.style.top = `${y}%`;
    wrap.dataset.pid = p.id;

    /* ★変更：他プレイヤーだけ「wrapごと」外側＆上へ（チップもタグ横のまま） */
    {
      const circleRect = playerCircle.getBoundingClientRect();
      const scale = (circleRect.width || 260) / 260;
      const out = 35 * scale;
      const up  = 35 * scale;

      const dx = Math.cos(angle);
      const dy = Math.sin(angle);

      if (p.id !== state.userId){
        wrap.style.transform = `translate(-50%,-50%) translate(${Math.round(dx*out)}px, ${Math.round(dy*out - up)}px)`;
      } else {
        wrap.style.transform = `translate(-50%,-50%)`;
      }
    }

    if (p.id === state.userId){
      const oc = document.createElement('div');
      oc.id = 'ownCircle';
      oc.className = 'owncircle' + (state.ownCircleVisible ? '' : ' hidden');
      wrap.appendChild(oc);
    }

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.textContent = p.name;

    if (curRevealPid && p.id === curRevealPid) tag.classList.add('turn');

    const s6 = state.special6;
    const s6Selection = getSpecial6Selection(p.id);
    const isS6Active = !!(s6 && s6.active && s6.stage === 'SELECT');
    wrap.classList.toggle('special6-pulse', isS6Active && !s6Selection);

    tag.onclick = () => {
      if (p.id === state.userId){
        if (isMyRevealTurn()) revealMyHand();
        return;
      }
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    const count = getShownCount(p.id);
    const fanCount = s6Selection ? Math.max(0, count - 1) : count;
    const isRevealed = !!revealedMap?.[p.id];

    /* ★変更：公開済み表示は「自分以外だけ」 */
    if (isRevealed && p.id !== state.userId){
      const rh = document.createElement('div');
      rh.className = 'reveal-hand';

      const cards = (state.hands?.[p.id] && Array.isArray(state.hands[p.id].cards)) ? state.hands[p.id].cards : [];
      cards.forEach(code => {
        const slot = document.createElement('div');
        slot.className = 'reveal-card';
        const el = code ? createCardElement(code) : createBackCardElement();
        slot.appendChild(el);
        rh.appendChild(slot);
      });

      tag.appendChild(rh);
    } else {
      if (p.id !== state.userId && fanCount > 0){
        const miniHand = document.createElement('div');
        miniHand.className = 'mini-hand';

        const spread = 70;
        const base = (fanCount > 1) ? (-spread/2) : 0;

        for (let idx2=0; idx2<fanCount; idx2++){
          const card = document.createElement('div');
          card.className = 'mini-card';
          card.textContent = '';

          const angleDeg = (fanCount > 1) ? base + (spread/(fanCount-1))*idx2 : 0;
          card.style.transform = `translate(-50%,0) rotate(${angleDeg}deg)`;
          card.style.zIndex = String(10 + idx2);
          miniHand.appendChild(card);
        }
        tag.appendChild(miniHand);

        if (s6Selection){
          const picked = document.createElement('div');
          picked.className = 'mini-card special6-picked-mini';
          picked.textContent = '';
          tag.appendChild(picked);
        }
      }
    }

    const ownedBox = document.createElement('div');
    ownedBox.className = 'owned-chips';

    wrap.appendChild(tag);
    wrap.appendChild(ownedBox);
    playerCircle.appendChild(wrap);
  });

  renderCenterBoard();
  maybePlayDealFromGame();

  renderOwnedChips();
  applyChipOwnersToPool();
  requestAnimationFrame(updateOwnCircleToFit);
}

kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   ★ ゲーム開始（既存維持）
   ========================= */
async function ensureGameExistsIfHost(){
  if (!state.isHost || !state.roomCode) return;
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  const snap = await get(gameRef);
  const cur = snap.val();
  const ok =
    cur &&
    typeof cur.started === 'boolean' &&
    Array.isArray(cur.deck) &&
    (Array.isArray(cur.boardCodes) || Array.isArray(cur.board)) &&
    (typeof cur.boardFaceUpCount === 'number' || typeof cur.boardFaceUpCount === 'undefined');
  if (!ok){
    await set(gameRef, { started:false, deck: [], boardCodes: [], boardFaceUpCount: 0, deal:null });
  }
}

/* =========================================================
   ：スタート/リセット時に「チップを全リセット」
   - owners: 全解除
   - faceDown: 全解除
   - poolPos: 初期配置へ戻す（→削除して初期レイアウトを再生成＆ホストが再コミット）
   - reveal: 公開フェーズも初期化
   ========================================================= */
async function resetAllChipsNow(){
  if (!state.roomCode) return;
  const base = `rooms/${state.roomCode}`;

  // DB: チップ関連を全初期化
  await Promise.all([
    remove(ref(db, `${base}/chipOwners`)),
    remove(ref(db, `${base}/chipPoolPos`)),
    remove(ref(db, `${base}/chipFaceDown`)),
    remove(ref(db, `${base}/reveal`)),
  ]);

  // ローカル状態も即初期化（表示が遅れない）
  state.chipOwners = {};
  state.chipPoolPos = {};
  state.chipFaceDown = {};
  state.reveal = null;

  // ：公開演出の履歴も初期化
  state._revealPopInited = false;
  state._prevRevealed = {};

  applyChipOwnersToPool();
  applyChipFacesToPool();
  renderOwnedChips();

  // 人数があるならプールを初期レイアウトで再描画
  const n = Number(state.room?.maxPlayers || 0);
  if (n){
    renderChipPool(n);

    // ★ホストは初期レイアウトをDBへ流して全員で一致させる
    if (state.isHost){
      setTimeout(() => {
        // レイアウト計測が安定してからコミット
        commitChipPoolPosAll();
      }, 80);
    }
  }
}

async function startGameDeal(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const seated = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? {
      seatIndex: Number(seatIndex),
      id: t.playerId,
      name: t.playerName || '名無し'
    } : null))
    .filter(Boolean)
    .sort((a,b) => a.seatIndex - b.seatIndex);

  const deck = shuffleInPlace(buildDeck52());

  const boardCodes = [];
  const boardFaceUpCount = 0;

  const hands = {};
  seated.forEach(p => hands[p.id] = { cards: [] });

  for (let round=0; round<2; round++){
    for (const p of seated){
      const c = deck.shift();
      if (c) hands[p.id].cards.push(c);
    }
  }

  const deal = {
    id: Date.now(),
    at: Date.now(),
    order: seated.map(p => p.id)
  };

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    set(ref(db, `${base}/game`), { started:true, deck, boardCodes, boardFaceUpCount, deal }),
    set(ref(db, `${base}/hands`), hands),
  ]);
}

hostSettingsBtn.addEventListener('click', async () => {
  if (!state.isHost) return;
  await ensureGameExistsIfHost();
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

btnGameStart.addEventListener('click', async () => {
  await hostStartGameWithDealCount(2);
});


btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/game`)),
    // ★チップ全初期化（リセットは従来通り）
    remove(ref(db, `${base}/chipOwners`)),
    remove(ref(db, `${base}/chipPoolPos`)),
    remove(ref(db, `${base}/chipFaceDown`)),
    remove(ref(db, `${base}/reveal`)),
    /* ：リセット時は左上カードも全部裏（=状態削除→デフォルト裏表示） */
    remove(ref(db, `${base}/sideCards`)),
  ]);

  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();

  state.game = { started:false, deck:[], boardCodes:[], boardFaceUpCount:0, deal:null };
  renderCenterBoard();

  state.reveal = null;
  state.sideCards = null;
  renderSideCards();

  // ：公開演出の履歴も初期化
  state._revealPopInited = false;
  state._prevRevealed = {};

  // ローカルも即初期化
  state.chipOwners = {};
  state.chipPoolPos = {};
  state.chipFaceDown = {};
  renderOwnedChips();
  renderChipPool(0);
});

window.addEventListener('load', () => {
  renderCenterBoard();
});

/* =========================================================
   ：左下の2つの山札（スペシャリスト/チャレンジ）【完全独立】
   DB: rooms/{room}/twoDecks
   ========================================================= */

const exElTwoDecks = document.getElementById('exTwoDecks');
const exSpecStack  = document.getElementById('exSpecStack');
const exChalStack  = document.getElementById('exChalStack');
const exSpecCount  = document.getElementById('exSpecCount');
const exChalCount  = document.getElementById('exChalCount');

const exDialogBackdrop = document.getElementById('exDialogBackdrop');
const exDialogText     = document.getElementById('exDialogText');
const exDialogYes      = document.getElementById('exDialogYes');
const exDialogNo       = document.getElementById('exDialogNo');

const EX_LONGPRESS_MS = 520;
const EX_MOVE_SLOP_PX = 8;

const EX_STACK_OFFSETS_10 = [
  {x:0.0,y:0.0,r: 0.0},{x:0.5,y:0.6,r:-0.4},{x:1.0,y:1.1,r: 0.3},{x:1.5,y:1.6,r:-0.3},
  {x:2.0,y:2.1,r: 0.5},{x:2.5,y:2.7,r:-0.2},{x:3.0,y:3.2,r: 0.4},{x:3.5,y:3.8,r:-0.5},
  {x:4.0,y:4.3,r: 0.3},{x:4.5,y:4.9,r:-0.2},
];

function exRndId(){
  return 'ex_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(16);
}

function exClamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
function exNow(){ return Date.now(); }

function exRoomPath(sub){
  return `rooms/${state.roomCode}/twoDecks${sub ? '/' + sub : ''}`;
}

async function exConfirm(message){
  return new Promise((resolve) => {
    exDialogText.textContent = message;
    exDialogBackdrop.classList.remove('hidden');

    const done = (v) => {
      exDialogBackdrop.classList.add('hidden');
      exDialogYes.removeEventListener('click', onYes);
      exDialogNo.removeEventListener('click', onNo);
      exDialogBackdrop.removeEventListener('click', onBg);
      resolve(v);
    };
    const onYes = (e) => { e.preventDefault(); e.stopPropagation(); done(true); };
    const onNo  = (e) => { e.preventDefault(); e.stopPropagation(); done(false); };
    const onBg  = (e) => { if (e.target === exDialogBackdrop) done(false); };

    exDialogYes.addEventListener('click', onYes);
    exDialogNo.addEventListener('click', onNo);
    exDialogBackdrop.addEventListener('click', onBg);
  });
}

function exShuffleInPlace(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function exNormalizePosPxTo01(leftPx, topPx){
  const w = Math.max(1, window.innerWidth);
  const h = Math.max(1, window.innerHeight);
  return {
    x: exClamp(leftPx / w, 0, 1),
    y: exClamp(topPx  / h, 0, 1),
  };
}
function exDenormalize01ToPx(x01, y01){
  const w = Math.max(1, window.innerWidth);
  const h = Math.max(1, window.innerHeight);
  return {
    left: Math.round(exClamp(Number(x01), 0, 1) * w),
    top : Math.round(exClamp(Number(y01), 0, 1) * h),
  };
}

/* ---------- DB ensure/subscribe ---------- */
let exInited = false;
let exSubUnsub = null;

const exLocal = {
  data: null,
  cardEls: new Map(), // id -> el
  dragging: null,     // {id, offX, offY, moved, raf, lastCommit}
  pressTimers: new Map()
};

async function exEnsureTwoDecksRoot(){
  if (!state.roomCode) return;
  const baseRef = ref(db, exRoomPath(''));
  const snap = await get(baseRef);
  if (!snap.exists()){
    await set(baseRef, {
      specialist: { stack: [1,2,3,4,5,6,7,8,9,10] },
      challenge:   { stack: [1,2,3,4,5,6,7,8,9,10] },
      cards: {}
    });
    return;
  }
  const v = snap.val() || {};
  const patch = {};
  if (!v.specialist?.stack) patch['specialist/stack'] = [1,2,3,4,5,6,7,8,9,10];
  if (!v.challenge?.stack)   patch['challenge/stack'] = [1,2,3,4,5,6,7,8,9,10];
  if (v.cards === undefined) patch['cards'] = {};
  if (Object.keys(patch).length){
    try{ await update(baseRef, patch); }catch(e){}
  }
}

function exSubscribe(){
  if (!state.roomCode) return;
  const baseRef = ref(db, exRoomPath(''));
  onValue(baseRef, (snap) => {
    exLocal.data = snap.val() || null;
    exRenderAll();
  });
}

function exShowUIIfJoined(){
  // 既存UIの流儀に合わせて「入室後(joinBox hidden)」に表示
  if (!joinBox || joinBox.classList.contains('hidden')){
    exElTwoDecks.classList.remove('hidden');
  }
}

/* ---------- Deck visual ---------- */
function exRenderDeckStack(stackEl, countEl, len){
  stackEl.querySelectorAll('.ex-deck-layer').forEach(n => n.remove());

  const empty = (len <= 0);
  stackEl.classList.toggle('empty', empty);
  if (countEl) countEl.textContent = String(Math.max(0, len));

  if (empty) return;

  // 山札感：最大10枚のレイヤー
  const layers = Math.min(10, Math.max(1, len));
  for (let i = layers - 1; i >= 0; i--){
    const layer = document.createElement('div');
    layer.className = 'ex-deck-layer';
    const o = EX_STACK_OFFSETS_10[i] || {x:0,y:0,r:0};
    layer.style.transform = `translate(${o.x}px, ${o.y}px) rotate(${o.r}deg)`;
    stackEl.insertBefore(layer, countEl);
  }
}

function exGetStack(deckKey){
  const d = exLocal.data || {};
  const st = d?.[deckKey]?.stack;
  if (Array.isArray(st)) return st.slice();
  // object形式で入っても耐える
  if (st && typeof st === 'object') return Object.values(st).map(Number).filter(n=>Number.isFinite(n));
  return [];
}

/* ---------- Draw/Shuffle ---------- */
async function exDrawTop(deckKey){
  if (!state.roomCode) return;

  const baseRef = ref(db, exRoomPath(''));
  const snap = await get(baseRef);
  const v = snap.val() || {};
  const cur = Array.isArray(v?.[deckKey]?.stack) ? v[deckKey].stack.slice() : [];

  if (!cur.length) return;

  // 「上が1」→ 配列先頭がトップ
  const topNum = cur.shift();

  // 出現位置：左下付近にランダムで少し散らす
  const spawnLeft = 110 + Math.round(Math.random() * 40);
  const spawnTop  = Math.max(40, window.innerHeight - 210 - Math.round(Math.random() * 30));
  const pos01 = exNormalizePosPxTo01(spawnLeft, spawnTop);

  const cardId = exRndId();
  const card = {
    deckKey,
    num: topNum,
    label: (deckKey === 'challenge') ? `C${topNum}` : String(topNum),
    x: pos01.x,
    y: pos01.y,
    rot: 0,
    z: exNow(),
    createdAt: exNow(),
    createdBy: state.userId,
    updatedAt: exNow(),
    updatedBy: state.userId,
    lockBy: null,
    lockAt: 0
  };

  // 先に山札を減らし、カードを生成
  try{
    await update(baseRef, {
      [`${deckKey}/stack`]: cur,
      [`cards/${cardId}`]: card
    });
  }catch(e){}
}

async function exShuffleDeck(deckKey){
  if (!state.roomCode) return;

  const ok = await exConfirm('シャッフルしますか？');
  if (!ok) return;

  const baseRef = ref(db, exRoomPath(''));
  const snap = await get(baseRef);
  const v = snap.val() || {};
  const cur = Array.isArray(v?.[deckKey]?.stack) ? v[deckKey].stack.slice() : [];
  if (cur.length <= 1) return;

  exShuffleInPlace(cur);
  try{
    await update(baseRef, { [`${deckKey}/stack`]: cur });
  }catch(e){}
}

async function exReturnCardToBottom(cardId){
  if (!state.roomCode) return;

  const ok = await exConfirm('山札の一番下に戻しますか？');
  if (!ok) return;

  const baseRef = ref(db, exRoomPath(''));
  const snap = await get(baseRef);
  const v = snap.val() || {};
  const card = v?.cards?.[cardId];
  if (!card) return;

  const deckKey = card.deckKey;
  const num = Number(card.num);
  if (!Number.isFinite(num)) return;

  const stack = Array.isArray(v?.[deckKey]?.stack) ? v[deckKey].stack.slice() : [];
  stack.push(num); // 一番下へ

  const patch = {};
  patch[`${deckKey}/stack`] = stack;
  patch[`cards/${cardId}`] = null; // remove

  try{
    // updateでnull指定は消える（RTDB）
    await update(baseRef, patch);
  }catch(e){
    try{ await remove(ref(db, exRoomPath(`cards/${cardId}`))); }catch(e2){}
    try{ await update(ref(db, exRoomPath(`${deckKey}`)), { stack }); }catch(e3){}
  }
}

/* ---------- Long press helper ---------- */
function exBindDeckInteractions(stackEl, deckKey){
  if (stackEl.dataset.exBound) return;
  stackEl.dataset.exBound = '1';

  let press = null;
  let firedLong = false;

  const clear = () => {
    if (press?.t) clearTimeout(press.t);
    press = null;
    firedLong = false;
  };

  stackEl.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    e.stopPropagation();
    firedLong = false;
    press = { x:e.clientX, y:e.clientY, t: 0 };
    press.t = setTimeout(async () => {
      firedLong = true;
      await exShuffleDeck(deckKey);
    }, EX_LONGPRESS_MS);
  }, { passive:false });

  stackEl.addEventListener('pointermove', (e) => {
    if (!press) return;
    const dx = e.clientX - press.x;
    const dy = e.clientY - press.y;
    if (Math.hypot(dx,dy) > EX_MOVE_SLOP_PX){
      clear();
    }
  }, { passive:false });

  stackEl.addEventListener('pointerup', async (e) => {
    if (!press) return;
    e.preventDefault();
    e.stopPropagation();

    const dx = e.clientX - press.x;
    const dy = e.clientY - press.y;
    const moved = Math.hypot(dx,dy) > EX_MOVE_SLOP_PX;

    const wasLong = firedLong;
    clear();

    if (wasLong) return;
    if (moved) return;

    await exDrawTop(deckKey);
  }, { passive:false });

  stackEl.addEventListener('pointercancel', clear, { passive:false });
}

/* ---------- Card render/drag ---------- */
function exMakeCardEl(cardId, card){
  const el = document.createElement('div');
  el.className = 'ex-float-card ' + (card.deckKey === 'challenge' ? 'ex-challenge' : 'ex-specialist');
  el.dataset.cardId = cardId;

  const mini = document.createElement('div');
  mini.className = 'ex-mini';

  const label = document.createElement('div');
  label.className = 'ex-label';
  label.textContent = card.label ?? '';

  el.appendChild(mini);
  el.appendChild(label);

  // long press to return
  let press = null;
  let firedLong = false;

  const clear = () => {
    if (press?.t) clearTimeout(press.t);
    press = null;
    firedLong = false;
  };

el.addEventListener('pointerdown', async (e) => {
    e.preventDefault();
    e.stopPropagation();

    firedLong = false;
    press = { x:e.clientX, y:e.clientY, t:0 };
    press.t = setTimeout(async () => {
      firedLong = true;
      // 返却ポップ（ドラッグと競合しない）
      await exReturnCardToBottom(cardId);
    }, EX_LONGPRESS_MS);

    // lock（ゆるい）
    update(ref(db, exRoomPath(`cards/${cardId}`)), {
      lockBy: state.userId,
      lockAt: exNow(),
      z: exNow(),
      updatedAt: exNow(),
      updatedBy: state.userId
    }).catch(()=>{});

    // drag start
    const r = el.getBoundingClientRect();
    exLocal.dragging = {
      id: cardId,
      offX: e.clientX - r.left,
      offY: e.clientY - r.top,
      moved: false,
      raf: 0,
      lastCommit: 0
    };

    const onMove = (ev) => exOnCardMove(ev);
    const onUp   = (ev) => exOnCardUp(ev, onMove, onUp);

    window.addEventListener('pointermove', onMove, { passive:false });
    window.addEventListener('pointerup', onUp, { passive:false });
    window.addEventListener('pointercancel', onUp, { passive:false });
  }, { passive:false });

  el.addEventListener('dblclick', (e) => {
    e.preventDefault();
    e.stopPropagation();
  }, { passive:false });

  function exOnCardMove(e){
    if (!exLocal.dragging || exLocal.dragging.id !== cardId) return;
    e.preventDefault();

    const dx = e.clientX - (press?.x ?? e.clientX);
    const dy = e.clientY - (press?.y ?? e.clientY);
    if (press && Math.hypot(dx,dy) > EX_MOVE_SLOP_PX){
      exLocal.dragging.moved = true;
      clear(); // 動いたら長押し解除
    }

    const left = e.clientX - exLocal.dragging.offX;
    const top  = e.clientY - exLocal.dragging.offY;

    el.style.left = `${Math.round(left)}px`;
    el.style.top  = `${Math.round(top)}px`;

    // DB commit throttle
    const now = exNow();
    if (now - exLocal.dragging.lastCommit < 50) return;
    exLocal.dragging.lastCommit = now;

    const pos01 = exNormalizePosPxTo01(left, top);
    update(ref(db, exRoomPath(`cards/${cardId}`)), {
      x: pos01.x,
      y: pos01.y,
      z: exNow(),
      updatedAt: exNow(),
      updatedBy: state.userId
    }).catch(()=>{});
  }

  function exOnCardUp(e, onMove, onUp){
    if (!exLocal.dragging || exLocal.dragging.id !== cardId) return;
    e.preventDefault();

    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);
    window.removeEventListener('pointercancel', onUp);

    const wasLong = firedLong;
    clear();

    // lock解除（返却で消えててもOK）
    update(ref(db, exRoomPath(`cards/${cardId}`)), {
      lockBy: null,
      lockAt: 0,
      updatedAt: exNow(),
      updatedBy: state.userId
    }).catch(()=>{});

    exLocal.dragging = null;

    if (wasLong) return;
  }

  document.body.appendChild(el);
  return el;
}

function exUpdateCardEl(el, card){
  const { left, top } = exDenormalize01ToPx(card.x ?? 0.2, card.y ?? 0.7);
  el.style.left = `${left}px`;
  el.style.top  = `${top}px`;
  el.style.transform = `rotate(${Number(card.rot || 0)}deg)`;
  el.style.zIndex = String(Number(card.z || 0) || 1);

  const label = el.querySelector('.ex-label');
  const text = card.label ?? ((card.deckKey === 'challenge') ? `C${card.num}` : String(card.num));
  if (label && label.textContent !== text) label.textContent = text;

  el.classList.toggle('ex-challenge', card.deckKey === 'challenge');
  el.classList.toggle('ex-specialist', card.deckKey !== 'challenge');
}

function exRenderCards(cardsObj){
  const cards = cardsObj && typeof cardsObj === 'object' ? cardsObj : {};

  // remove missing
  for (const [id, el] of exLocal.cardEls.entries()){
    if (!cards[id]){
      if (el && el.parentNode) el.remove();
      exLocal.cardEls.delete(id);
    }
  }

  // add/update
  for (const [id, card] of Object.entries(cards)){
    if (!card) continue;
    let el = exLocal.cardEls.get(id);
    if (!el){
      el = exMakeCardEl(id, card);
      exLocal.cardEls.set(id, el);
    }
    // dragging中はローカル表示優先（ワープ防止）
    if (exLocal.dragging && exLocal.dragging.id === id) continue;
    exUpdateCardEl(el, card);
  }
}

/* ---------- Master render ---------- */
function exRenderAll(){
  exShowUIIfJoined();
  if (!exLocal.data) return;

  const specStack = exGetStack('specialist');
  const chalStack = exGetStack('challenge');

  exRenderDeckStack(exSpecStack, exSpecCount, specStack.length);
  exRenderDeckStack(exChalStack, exChalCount, chalStack.length);

  exBindDeckInteractions(exSpecStack, 'specialist');
  exBindDeckInteractions(exChalStack, 'challenge');

  exRenderCards(exLocal.data.cards);
}

/* ---------- Boot ---------- */
(function exBoot(){
  const timer = setInterval(async () => {
    if (exInited) return;
    if (!state.roomCode) return; // 入室後に開始
    exInited = true;
    clearInterval(timer);

    try{ await exEnsureTwoDecksRoot(); }catch(e){}
    exSubscribe();

    // resizeで位置再計算（正規化→px変換）
    window.addEventListener('resize', () => {
      if (!exLocal.data?.cards) return;
      for (const [id, card] of Object.entries(exLocal.data.cards)){
        const el = exLocal.cardEls.get(id);
        if (!el || !card) continue;
        if (exLocal.dragging && exLocal.dragging.id === id) continue;
        exUpdateCardEl(el, card);
      }
    });
  }, 250);
})();


</script>

</body>
</html>
