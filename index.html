

<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>テンプレ</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* ★ main背景：入室前/入室後で切替 */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  /* ★ 着席ポップ */
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  /* ★ ホスト人数選択中：参加者に出す黒ポップ（下固定） */
  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  /* =========================
     ★ プレイヤー円配置用（黒リング + 横長楕円）
     ========================= */
  .player-circle{
    position:relative;
    width:360px;
    height:260px;
    margin:20px auto 0;
    box-sizing:border-box;
    border:none;
  }
  .player-circle::before{
    content:'';
    position:absolute;
    left:50%; top:50%;
    width:100%;
    height:100%;
    transform:translate(-50%,-50%);
    border-radius:999px;
    border:3px solid #111;
    pointer-events:none;
    box-sizing:border-box;
  }
  .player-circle.hide-ring::before{ display:none; }

  /* ★ 追加：ネームプレート + 右チップ列をまとめて配置する外枠 */
  .player-wrap{
    position:absolute;
    left:0; top:0;                 /* JSで left/top を指定 */
    transform:translate(-50%,-50%);/* 座標は中心基準 */
    display:flex;
    align-items:center;
    gap:6px;                       /* ネームプレートとチップの間 */
  }

  /* ★ 変更：player-tag は「ピル」本体だけにする（絶対配置しない） */
  .player-tag{
    position:relative; /* mini-hand / mycircle の基準 */
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    display:inline-flex;align-items:center;gap:6px;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  /* ★ 自分タグ右にチップが増える列 */
  .my-chip-row{
    display:flex; gap:6px; align-items:center;
  }

  /* =========================
     ★ mycircle（自分タグ周りの円リング）
     ========================= */
  .mycircle{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:calc(100% + 18px);
    height:calc(100% + 18px);
    border-radius:999px;
    border:2px solid #111;   /* 今は黒 */
    pointer-events:none;     /* クリック邪魔しない */
    box-sizing:border-box;
  }
  /* ★ 後で非表示：mycircle にこのクラスを付けるだけ */
  .mycircle.hide-mycircle{ display:none; }

  /* 他プレイヤーのミニカード（ネームタグの下に扇状） */
  .player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:60px;height:30px;pointer-events:none;
  }
  .player-tag .mini-card{
    position:absolute;left:50%;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background:linear-gradient(135deg,#e5e7eb,#cbd5f5);
    font-size:10px;display:flex;align-items:center;justify-content:center;
    transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }

  /* 自分の手札表示（大きめ横並び） */
  .my-hand-wrapper{margin-top:16px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand{display:flex;justify-content:center;gap:8px;margin-top:6px;min-height:100px;}

  /* ★ 追い出し確認ダイアログ */
  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  /* ★ ホスト用 設定ボタン（右下固定） */
  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  /* ★ 設定ポップ（ホスト専用パネル） */
  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  /* 詳細情報消す用 */
  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  /* =========================
     ★ 追加：左下「？」ボタン
     ========================= */
  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  /* ★ 追加：ヘルプ一覧ポップ */
  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
  }
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    display:flex;align-items:center;justify-content:center;
    font-size:12px;font-weight:700;color:#444;
  }
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  /* =========================
     ★ 中央「場札(5) + 左に山札」
     ========================= */
  .center-table{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    display:flex; align-items:center; gap:10px;
    pointer-events:none;
  }

  /* 山札（見た目：カード背面を重ねる） */
  .deck-stack{
    width:54px;height:78px;
    position:relative;
    border-radius:10px;
    pointer-events:auto;
    cursor:pointer;
  }
  .deck-stack.empty{
    outline:1px dashed rgba(255,255,255,.45);
    outline-offset:-4px;
    background:rgba(20,20,20,.22);
    box-shadow:none;
  }
  .deck-layer{
    position:absolute; inset:0;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.65);
    box-shadow:none;
    overflow:hidden;
    background:
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
      repeating-linear-gradient(45deg, rgba(255,255,255,.10) 0 2px, rgba(255,255,255,0) 2px 6px),
      linear-gradient(135deg, rgba(185,28,28,.95), rgba(127,29,29,.95));
  }
  .deck-layer::after{
    content:'';
    position:absolute; inset:6px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.45);
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.15);
  }
  .deck-count{
    position:absolute; right:-6px; top:-8px;
    min-width:22px;height:18px;padding:0 6px;
    display:flex;align-items:center;justify-content:center;
    border-radius:999px;
    background:rgba(0,0,0,.55);
    color:#fff;font-size:11px;font-weight:900;
    text-shadow:none;
    border:1px solid rgba(255,255,255,.25);
    pointer-events:none;
  }

  .board-row{ display:flex; gap:8px; pointer-events:auto; }
  .board-slot{
    width:48px;height:72px;
    border-radius:10px;
    border:none;
    background:transparent;
    box-shadow:none;
    backdrop-filter:none;
    display:flex;align-items:center;justify-content:center;
    position:relative;
    overflow:visible;
    pointer-events:auto;
  }
  .board-slot.has-card{ cursor:pointer; }

  /* =========================
     ★ トランプ面
     ========================= */
  .pcard{
    width:60px;height:90px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    box-shadow:0 4px 12px rgba(0,0,0,.15);
    position:relative;
    overflow:hidden;
    user-select:none;
  }
  .pcard.red{ color:#c1121f; }
  .pcard.black{ color:#111; }

  .pcard .corner{
    position:absolute;
    display:flex;flex-direction:column;align-items:center;
    font-weight:900;
    line-height:1;
    gap:0px;
  }
  .pcard .corner .rank{ font-size:10px; }
  .pcard .corner .suit{ font-size:10px; transform:translateY(-1px); }
  .pcard .corner.tl{ left:3px; top:3px; }
  .pcard .corner.br{ right:3px; bottom:3px; transform:rotate(180deg); }

  .pcard .pips{
    position:absolute;
    left:10px; right:10px;
    top:16px; bottom:16px;
  }
  .pcard .pip{
    position:absolute;
    transform:translate(-50%,-50%);
    font-weight:900;
    font-size:12px;
  }
  .pcard .pip.flip{ transform:translate(-50%,-50%) rotate(180deg); }
  .pcard[data-rank="A"] .pip{ font-size:26px; }

  .pcard .face-holder{
    position:absolute; inset:14px 10px;
    border-radius:8px;
    display:flex;align-items:center;justify-content:center;
    font-weight:1000;
    font-size:28px;
    opacity:.20;
    letter-spacing:.02em;
  }
  .pcard .face-suit{
    position:absolute;
    left:50%; top:52%;
    transform:translate(-50%,-50%);
    font-size:22px;
    opacity:.35;
    font-weight:900;
  }

  .my-card{ width:60px;height:90px; }

  .backcard{
    width:60px;height:90px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.65);
    overflow:hidden;
    background:
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
      repeating-linear-gradient(45deg, rgba(255,255,255,.10) 0 2px, rgba(255,255,255,0) 2px 6px),
      linear-gradient(135deg, rgba(185,28,28,.95), rgba(127,29,29,.95));
    box-shadow:0 4px 12px rgba(0,0,0,.15);
    position:relative;
  }
  .backcard::after{
    content:'';
    position:absolute;
    inset:6px;
    border-radius:6px;
    border:1px solid rgba(255,255,255,.45);
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.15);
  }

  .fly-card{
    position:fixed;
    width:60px;height:90px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.65);
    overflow:hidden;
    z-index:9999;
    pointer-events:none;
    background:
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
      repeating-linear-gradient(45deg, rgba(255,255,255,.10) 0 2px, rgba(255,255,255,0) 2px 6px),
      linear-gradient(135deg, rgba(185,28,28,.95), rgba(127,29,29,.95));
  }
  .fly-card::after{
    content:'';
    position:absolute; inset:6px;
    border-radius:6px;
    border:1px solid rgba(255,255,255,.45);
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.15);
  }

  /* =========================
     ★ 右上：チップ置き場（16枚）
     ========================= */
  .chip-tray{
    position:fixed;
    right:16px;
    top:68px;            /* header下 */
    z-index:260;
    display:grid;
    grid-template-columns: repeat(4, auto);
    gap:8px;
    padding:10px;
    border-radius:14px;
    background:rgba(255,255,255,.86);
    border:1px solid #eee;
    backdrop-filter: blur(6px);
    box-shadow:0 10px 26px rgba(0,0,0,.14);
    user-select:none;
    touch-action:none;
  }
  .chip-tray.hidden{display:none;}

  /* ドラッグ中の追従チップ（見た目は同じ） */
  .drag-ghost{
    position:fixed;
    left:0; top:0;
    z-index:99999;
    pointer-events:none;
    transform:translate(-9999px,-9999px);
    filter: drop-shadow(0 10px 18px rgba(0,0,0,.25));
  }

  /* =========================
     ★ チップSVG（サイズはJSでネームタグ高に合わせる）
     ========================= */
  svg.chip{
    display:block;
    width:40px; height:40px; /* 初期。入室後にJSで置換 */
    cursor:grab;
    touch-action:none;
  }
  .chip-wrap{width:40px;height:40px;display:flex;align-items:center;justify-content:center;}
  .chip-wrap:active svg.chip{ cursor:grabbing; }
</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">リンクコピー</button>
  </div>
</header>

<!-- ★ 右上チップ置き場（入室後に表示） -->
<div id="chipTray" class="chip-tray hidden"></div>
<!-- ★ ドラッグ追従用 -->
<div id="chipDragGhost" class="drag-ghost"></div>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">
      <div id="centerTable" class="center-table">
        <div id="deckStack" class="deck-stack empty" title="山札">
          <div id="deckCount" class="deck-count">52</div>
        </div>
        <div id="boardRow" class="board-row" aria-label="場札">
          <div class="board-slot" data-slot="0"></div>
          <div class="board-slot" data-slot="1"></div>
          <div class="board-slot" data-slot="2"></div>
          <div class="board-slot" data-slot="3"></div>
          <div class="board-slot" data-slot="4"></div>
        </div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で山札(52)を生成し、全プレイヤーへ2枚ずつ配布。<br>
    場札は最初0枚です。山札クリックで「裏3枚→場札クリックで順に表→山札で最大5枚」。
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

// ▼ Firebase 設定
const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};
const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

// ★ userId をタブ単位で固定（タブごとに別ID）
const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

// ▼ 状態
const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  room: {},
  game: { started:false, deck: [], boardCodes: [], boardFaceUpCount: 0, deal:null },

  dealing: false,
  dealShownCounts: null,

  // ★ 自分タグ右に追加したチップ
  myChips: [] // [{type:'white'|'yellow'|'orange'|'red', id:string}]
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const chipTray = document.getElementById('chipTray');
const chipDragGhost = document.getElementById('chipDragGhost');

const ROLE_HELP = [
  { name: "カード1", text: "ああああ" },
  { name: "カード2", text: "いいいい" },
  { name: "カード3", text: "うううう" },
  { name: "カード4", text: "うううう" },
];

function renderHelpList(){
  helpBody.innerHTML = '';
  ROLE_HELP.forEach((r, idx) => {
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card';
    card.textContent = `CARD ${idx+1}`;

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${r.name}</div>
      <div class="text">${r.text}</div>
    `;

    row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  });
}
function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

let isDealAnimating = false;

function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

/* =========================================================
   ★ チップSVG（参照デザインを縮小して“円形/黒円/スポーク/色ライン”）
   - 直径はJSで「ネームタグの高さ」と同じに合わせる
   ========================================================= */
const CHIP_COLORS = {
  white:  { key:"白", fill:"#F7F7F7", stroke:"#CFCFCF" },
  yellow: { key:"黄", fill:"#FFD84A", stroke:"#C9A600" },
  orange: { key:"オレンジ", fill:"#FF9A2F", stroke:"#D06B00" },
  red:    { key:"赤", fill:"#FF4B4B", stroke:"#C82828" },
};

const toRad = d => d * Math.PI / 180;
function polar(cx, cy, r, angRad){ return { x: cx + Math.cos(angRad)*r, y: cy + Math.sin(angRad)*r }; }

function spokeSectorsData(cx, cy, rInnerEdge, rOuterEdge, spokeThickness, stepDeg = 60, startDeg = -90){
  const midR = (rInnerEdge + rOuterEdge) / 2;
  const halfW = spokeThickness / 2;
  let halfAngle = Math.asin(Math.min(1, halfW / Math.max(1e-6, midR)));
  halfAngle = Math.min(halfAngle, Math.PI/2 - 1e-3);

  const out = [];
  let idx = 0;
  for(let deg = startDeg; deg < startDeg + 360; deg += stepDeg){
    const a = toRad(deg);
    const a1 = a - halfAngle;
    const a2 = a + halfAngle;

    const pIn1  = polar(cx, cy, rInnerEdge, a1);
    const pOut1 = polar(cx, cy, rOuterEdge, a1);
    const pOut2 = polar(cx, cy, rOuterEdge, a2);
    const pIn2  = polar(cx, cy, rInnerEdge, a2);

    const d = [
      `M ${pIn1.x.toFixed(2)} ${pIn1.y.toFixed(2)}`,
      `L ${pOut1.x.toFixed(2)} ${pOut1.y.toFixed(2)}`,
      `A ${rOuterEdge.toFixed(2)} ${rOuterEdge.toFixed(2)} 0 0 1 ${pOut2.x.toFixed(2)} ${pOut2.y.toFixed(2)}`,
      `L ${pIn2.x.toFixed(2)} ${pIn2.y.toFixed(2)}`,
      `A ${rInnerEdge.toFixed(2)} ${rInnerEdge.toFixed(2)} 0 0 0 ${pIn1.x.toFixed(2)} ${pIn1.y.toFixed(2)}`,
      `Z`
    ].join(" ");

    out.push({ d, angle: a, idx });
    idx++;
  }
  return out;
}
function markerOffsets(lineCount, spokeThickness){
  if(lineCount <= 0) return [];
  const spread = spokeThickness * 0.25;
  if(lineCount === 1) return [0];
  if(lineCount === 2) return [-spread * 0.75, spread * 0.75];
  return [-spread, 0, spread];
}
function markerLinesMarkup(spokesData, cx, cy, rInnerEdge, rOuterEdge, spokeThickness, lineCount, lineColor, clipId){
  if(lineCount <= 0) return "";
  const offsets = markerOffsets(lineCount, spokeThickness);
  const sw = 2.2;

  const segs = [];
  for(const sp of spokesData){
    const a = sp.angle;
    for(const t of offsets){
      const daIn  = t / rInnerEdge;
      const daOut = t / rOuterEdge;
      const pIn  = polar(cx, cy, rInnerEdge, a + daIn);
      const pOut = polar(cx, cy, rOuterEdge, a + daOut);

      segs.push(
        `<path d="M ${pIn.x.toFixed(2)} ${pIn.y.toFixed(2)} L ${pOut.x.toFixed(2)} ${pOut.y.toFixed(2)}"
           fill="none" stroke="${lineColor}" stroke-width="${sw}"
           stroke-linecap="round" stroke-linejoin="round" />`
      );
    }
  }
  return `<g clip-path="url(#${clipId})">${segs.join("")}</g>`;
}
function chipSVG(type, uid){
  const c = CHIP_COLORS[type] || CHIP_COLORS.white;

  const vb = 100;
  const cx = 50, cy = 50;

  const outerR = 46;
  const outerStroke = 4;

  const innerCircleR = 33;
  const innerStroke = 2.2;

  const spokeThickness = 16;
  const rInnerEdge = innerCircleR + innerStroke/2;
  const rOuterEdge = outerR - outerStroke/2;

  const spokesData = spokeSectorsData(cx, cy, rInnerEdge, rOuterEdge, spokeThickness, 60, -90);
  const spokesMarkup = spokesData.map(s => `<path d="${s.d}" fill="#111" />`).join("");

  const lineCount =
    (c.key === "黄") ? 1 :
    (c.key === "オレンジ") ? 2 :
    (c.key === "赤") ? 3 : 0;

  const clipId = `spokes-clip-${uid}`;
  const coloredLines = markerLinesMarkup(
    spokesData, cx, cy, rInnerEdge, rOuterEdge, spokeThickness,
    lineCount, c.fill, clipId
  );

  return `
    <svg class="chip" viewBox="0 0 ${vb} ${vb}" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="チップ ${c.key}">
      <defs>
        <clipPath id="${clipId}">
          ${spokesData.map(s => `<path d="${s.d}"></path>`).join("")}
        </clipPath>
      </defs>

      <!-- ベース -->
      <circle cx="${cx}" cy="${cy}" r="${outerR}" fill="${c.fill}"/>

      <!-- 太スポーク -->
      ${spokesMarkup}

      <!-- 色ライン（黄=1 / 橙=2 / 赤=3 / 白=なし） -->
      ${coloredLines}

      <!-- 外周ストローク -->
      <circle cx="${cx}" cy="${cy}" r="${outerR}" fill="none" stroke="${c.stroke}" stroke-width="${outerStroke}"/>

      <!-- 中の黒円 -->
      <circle cx="${cx}" cy="${cy}" r="${innerCircleR}" fill="none" stroke="#111" stroke-width="${innerStroke}"/>
    </svg>
  `;
}

/* =========================================================
   ★ チップドラッグ＆ドロップ
   - 右上16枚は「元位置に戻る」
   - mycircleにドロップしたら state.myChips に追加 → 自分タグ“横”に追加表示
   ========================================================= */
let drag = {
  active:false,
  type:null,
  fromEl:null,
  startRect:null,
  offsetX:0,
  offsetY:0,
};

function setAllChipSizeToTag(){
  // ネームタグの高さと同じ直径にする
  const myTag = document.querySelector('.player-tag.me');
  if (!myTag) return;

  const h = Math.round(myTag.getBoundingClientRect().height);
  const size = Math.max(28, Math.min(64, h)); // 安全クランプ
  document.documentElement.style.setProperty('--chipSize', size + 'px');

  // tray内 chip
  chipTray.querySelectorAll('svg.chip').forEach(svg=>{
    svg.style.width = size+'px';
    svg.style.height= size+'px';
  });
  // my-chip-row chip
  document.querySelectorAll('.my-chip-row svg.chip').forEach(svg=>{
    svg.style.width = size+'px';
    svg.style.height= size+'px';
  });
}

function buildChipTray(){
  chipTray.innerHTML = '';
  // 16枚：4色×4回（並びは 白,黄,橙,赤 を4セット）
  const types = ['white','yellow','orange','red'];
  let uid = 1;
  for(let i=0;i<16;i++){
    const t = types[i % types.length];
    const wrap = document.createElement('div');
    wrap.className = 'chip-wrap';
    wrap.dataset.type = t;
    wrap.innerHTML = chipSVG(t, 'tray'+(uid++));
    chipTray.appendChild(wrap);
  }
  // pointer操作
  chipTray.querySelectorAll('.chip-wrap').forEach(w=>{
    w.addEventListener('pointerdown', onChipPointerDown);
  });
  setAllChipSizeToTag();
}

function onChipPointerDown(e){
  const wrap = e.currentTarget;
  const svg = wrap.querySelector('svg.chip');
  if (!svg) return;

  e.preventDefault();
  e.stopPropagation();

  wrap.setPointerCapture?.(e.pointerId);

  const rect = svg.getBoundingClientRect();
  drag.active = true;
  drag.type = wrap.dataset.type;
  drag.fromEl = wrap;
  drag.startRect = rect;
  drag.offsetX = e.clientX - rect.left;
  drag.offsetY = e.clientY - rect.top;

  chipDragGhost.innerHTML = chipSVG(drag.type, 'ghost');
  const ghostSvg = chipDragGhost.querySelector('svg.chip');
  ghostSvg.style.width = rect.width+'px';
  ghostSvg.style.height= rect.height+'px';

  chipDragGhost.style.transform = `translate(${rect.left}px, ${rect.top}px)`;
  window.addEventListener('pointermove', onChipPointerMove, {passive:false});
  window.addEventListener('pointerup', onChipPointerUp, {passive:false});
}

function onChipPointerMove(e){
  if (!drag.active) return;
  e.preventDefault();
  const x = e.clientX - drag.offsetX;
  const y = e.clientY - drag.offsetY;
  chipDragGhost.style.transform = `translate(${x}px, ${y}px)`;
}

function isPointInsideRect(x,y, r){
  return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
}

function onChipPointerUp(e){
  if (!drag.active) return;
  e.preventDefault();

  // ドロップ判定：mycircleのバウンディングに入っていればOK
  const mycircle = document.querySelector('.player-tag.me .mycircle');
  let dropped = false;

  if (mycircle){
    const r = mycircle.getBoundingClientRect();
    if (isPointInsideRect(e.clientX, e.clientY, r)){
      dropped = true;
    }
  }

  if (dropped){
    state.myChips.push({ type: drag.type, id: crypto.randomUUID() });
    renderHands(); // 右側列を描き直す
  }

  chipDragGhost.innerHTML = '';
  chipDragGhost.style.transform = `translate(-9999px,-9999px)`;

  drag.active = false;
  drag.type = null;
  drag.fromEl = null;
  drag.startRect = null;

  window.removeEventListener('pointermove', onChipPointerMove);
  window.removeEventListener('pointerup', onChipPointerUp);
}

/* =========================
   ★ 追加：トランプ52枚デッキ生成
   ========================= */
function buildDeck52(){
  const suits = [{ s:"♠" },{ s:"♥" },{ s:"♦" },{ s:"♣" }];
  const ranks = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const deck = [];
  for (const su of suits){
    for (const r of ranks){
      deck.push(`${su.s}${r}`);
    }
  }
  return deck;
}
function shuffleInPlace(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* =========================
   ★ カード面描画
   ========================= */
function parseCard(code){
  if (!code || typeof code !== 'string') return null;
  const suit = code.slice(0,1);
  const rank = code.slice(1);
  const isRed = (suit === '♥' || suit === '♦');
  return { suit, rank, isRed };
}
function pipToPercent(row, col){
  const rows = 5, cols = 3;
  const x = (col + 0.5) / cols * 100;
  const y = (row + 0.5) / rows * 100;
  return { x, y };
}
const PIP_LAYOUT = {
  2: [[0,1],[4,1]],
  3: [[0,1],[2,1],[4,1]],
  4: [[0,0],[0,2],[4,0],[4,2]],
  5: [[0,0],[0,2],[2,1],[4,0],[4,2]],
  6: [[0,0],[0,2],[2,0],[2,2],[4,0],[4,2]],
  7: [[0,0],[0,2],[0,1],[2,0],[2,2],[4,0],[4,2]],
  8: [[0,0],[0,2],[1,1],[2,0],[2,2],[3,1],[4,0],[4,2]],
  9: [[0,0],[0,2],[1,1],[2,0],[2,2],[2,1],[3,1],[4,0],[4,2]],
  10:[[0,0],[0,2],[1,1],[1,0],[1,2],[3,0],[3,2],[3,1],[4,0],[4,2]]
};
function createCardElement(code){
  const c = parseCard(code);
  if (!c) return document.createElement('div');

  const el = document.createElement('div');
  el.className = `pcard ${c.isRed ? 'red' : 'black'}`;
  el.dataset.rank = c.rank;
  el.dataset.suit = c.suit;

  const cornerTL = document.createElement('div');
  cornerTL.className = 'corner tl';
  cornerTL.innerHTML = `<div class="rank">${c.rank}</div><div class="suit">${c.suit}</div>`;

  const cornerBR = document.createElement('div');
  cornerBR.className = 'corner br';
  cornerBR.innerHTML = `<div class="rank">${c.rank}</div><div class="suit">${c.suit}</div>`;

  el.appendChild(cornerTL);
  el.appendChild(cornerBR);

  const rankNum = (c.rank === 'A') ? 1 : Number(c.rank);
  const isFace = (c.rank === 'J' || c.rank === 'Q' || c.rank === 'K');

  const pips = document.createElement('div');
  pips.className = 'pips';

  if (isFace){
    const face = document.createElement('div');
    face.className = 'face-holder';
    face.textContent = c.rank;

    const fs = document.createElement('div');
    fs.className = 'face-suit';
    fs.textContent = c.suit;

    el.appendChild(face);
    el.appendChild(fs);
  } else {
    if (c.rank === 'A'){
      const {x,y} = pipToPercent(2,1);
      const pip = document.createElement('div');
      pip.className = 'pip';
      pip.style.left = `${x}%`;
      pip.style.top  = `${y}%`;
      pip.textContent = c.suit;
      pips.appendChild(pip);
    } else {
      const layout = PIP_LAYOUT[rankNum] || [];
      layout.forEach(([r, col]) => {
        const {x,y} = pipToPercent(r,col);
        const pip = document.createElement('div');
        pip.className = 'pip' + (r >= 3 ? ' flip' : '');
        pip.style.left = `${x}%`;
        pip.style.top  = `${y}%`;
        pip.textContent = c.suit;
        pips.appendChild(pip);
      });
    }
    el.appendChild(pips);
  }
  return el;
}
function createBackCardElement(){
  const el = document.createElement('div');
  el.className = 'backcard';
  return el;
}

/* =========================
   ★ 山札の“重なり”描画
   ========================= */
const STACK_MAX = 15;
const STACK_OFFSETS = [
  {x:0.0,y:0.0,r: 0.0},{x:0.4,y:0.5,r:-0.3},{x:0.9,y:0.9,r: 0.2},{x:1.2,y:1.5,r:-0.4},
  {x:1.8,y:1.9,r: 0.5},{x:2.2,y:2.5,r:-0.2},{x:2.8,y:2.9,r: 0.4},{x:3.1,y:3.6,r:-0.6},
  {x:3.7,y:4.0,r: 0.3},{x:4.2,y:4.6,r:-0.3},{x:4.8,y:5.0,r: 0.6},{x:5.2,y:5.7,r:-0.4},
  {x:5.8,y:6.1,r: 0.4},{x:6.2,y:6.8,r:-0.2},{x:6.8,y:7.2,r: 0.2},
];
function calcStackLayers(deckLen){
  const removed = 52 - deckLen;
  const layers = STACK_MAX - Math.floor(removed / 2);
  return Math.max(1, Math.min(STACK_MAX, layers));
}
function renderDeckVisual(deckStackEl, deckLen, started){
  const shownLen = started ? deckLen : 52;
  deckStackEl.classList.toggle('empty', started && shownLen === 0);

  const countEl = deckStackEl.querySelector('#deckCount');
  deckStackEl.querySelectorAll('.deck-layer').forEach(n => n.remove());

  const layers = (started && shownLen === 0) ? 0 : calcStackLayers(shownLen);
  for (let i = layers - 1; i >= 0; i--){
    const layer = document.createElement('div');
    layer.className = 'deck-layer';
    const o = STACK_OFFSETS[i] || {x:0,y:0,r:0};
    layer.style.transform = `translate(${o.x}px, ${o.y}px) rotate(${o.r}deg)`;
    deckStackEl.insertBefore(layer, countEl);
  }
  if (countEl) countEl.textContent = String(shownLen);
}

/* =========================
   ★ 中央UI（山札・場札）描画
   ========================= */
function getBoardCodes(){
  const g = state.game || {};
  const codes = Array.isArray(g.boardCodes) ? g.boardCodes : (Array.isArray(g.board) ? g.board : []);
  return codes.filter(Boolean);
}
function getBoardFaceUpCount(){
  const g = state.game || {};
  const n = Number(g.boardFaceUpCount || 0);
  return Number.isFinite(n) ? n : 0;
}
function attachCenterInteractions(){
  const deckStackEl = playerCircle.querySelector('#deckStack');
  if (deckStackEl && !deckStackEl.dataset.bound){
    deckStackEl.dataset.bound = '1';
    deckStackEl.addEventListener('click', onDeckClick);
  }
  const boardRowEl = playerCircle.querySelector('#boardRow');
  if (boardRowEl && !boardRowEl.dataset.bound){
    boardRowEl.dataset.bound = '1';
    boardRowEl.addEventListener('click', onBoardClick);
  }
}
function renderCenterBoard(){
  const deckStackEl = playerCircle.querySelector('#deckStack');
  const boardRowEl  = playerCircle.querySelector('#boardRow');
  if (!deckStackEl || !boardRowEl) return;

  attachCenterInteractions();

  const started = !!state.game?.started;
  const deck = Array.isArray(state.game?.deck) ? state.game.deck : [];
  const boardCodes = started ? getBoardCodes() : [];
  const faceUpCount = started ? Math.min(getBoardFaceUpCount(), boardCodes.length) : 0;

  renderDeckVisual(deckStackEl, started ? deck.length : 52, started);

  const slots = boardRowEl.querySelectorAll('.board-slot');
  slots.forEach((slot, i) => {
    slot.innerHTML = '';
    slot.classList.remove('has-card');

    if (!started) return;
    if (i < boardCodes.length){
      slot.classList.add('has-card');
      if (i < faceUpCount){
        const cardEl = createCardElement(boardCodes[i]);
        cardEl.style.width = '48px';
        cardEl.style.height = '72px';
        slot.appendChild(cardEl);
      } else {
        const back = createBackCardElement();
        slot.appendChild(back);
      }
    }
  });
}

/* =========================
   ★ 配布アニメ（略：あなたの元コードのまま）
   ========================= */
function getDealSeenKey(){ return state.roomCode ? `dealSeen_${state.roomCode}` : `dealSeen_unknown`; }
function getShownCount(pid){
  if (state.dealing && state.dealShownCounts && typeof state.dealShownCounts[pid] === 'number'){
    return state.dealShownCounts[pid];
  }
  const handData = state.hands[pid];
  return (handData && Array.isArray(handData.cards)) ? handData.cards.length : 0;
}
async function waitForTags(order){
  for (let i=0; i<40; i++){
    const ok = order.every(pid => document.querySelector(`.player-tag[data-pid="${pid}"]`));
    if (ok) return true;
    await sleep(50);
  }
  return false;
}
async function animateOneFly(startX, startY, endX, endY, extraRot=0){
  const el = document.createElement('div');
  el.className = 'fly-card';
  el.style.left = '0px';
  el.style.top  = '0px';
  document.body.appendChild(el);

  const halfW = 30, halfH = 45;
  const sx = startX - halfW, sy = startY - halfH;
  const ex = endX - halfW,   ey = endY - halfH;
  const mx = (sx + ex) / 2;
  const my = (sy + ey) / 2 - 60;

  const anim = el.animate([
    { transform:`translate(${sx}px, ${sy}px) rotate(${0+extraRot}deg) scale(1)` },
    { transform:`translate(${mx}px, ${my}px) rotate(${2+extraRot}deg) scale(1.02)` },
    { transform:`translate(${ex}px, ${ey}px) rotate(${0+extraRot}deg) scale(1)` },
  ], { duration: 380, easing: 'cubic-bezier(.22,.84,.44,1)', fill: 'forwards' });

  await anim.finished.catch(()=>{});
  el.remove();
}
async function runDealAnimation(order){
  if (isDealAnimating) return;
  isDealAnimating = true;

  state.dealShownCounts = {};
  order.forEach(pid => state.dealShownCounts[pid] = 0);

  state.dealing = true;
  renderHands();

  try{
    const deckEl = document.getElementById('deckStack');
    if (!deckEl) return;

    const d = deckEl.getBoundingClientRect();
    const startX = d.left + d.width/2;
    const startY = d.top  + d.height/2;

    for (let round=0; round<2; round++){
      for (let i=0; i<order.length; i++){
        const pid = order[i];
        const tag = document.querySelector(`.player-tag[data-pid="${pid}"]`);
        if (!tag) continue;

        const tr = tag.getBoundingClientRect();
        const endX = tr.left + tr.width/2;
        const endY = tr.top + tr.height/2 + 26;

        await animateOneFly(startX, startY, endX, endY, (i%2===0? -1: 1));
        state.dealShownCounts[pid] = (state.dealShownCounts[pid] ?? 0) + 1;
        renderHands();
        await sleep(70);
      }
      await sleep(140);
    }
  } finally {
    state.dealing = false;
    state.dealShownCounts = null;
    isDealAnimating = false;
    renderHands();
  }
}
async function maybePlayDealFromGame(){
  const started = !!state.game?.started;
  const deal = state.game?.deal;
  if (!started || !deal || !deal.id || !Array.isArray(deal.order)) return;

  const at = typeof deal.at === 'number' ? deal.at : deal.id;
  if (Date.now() - at > 20000) {
    sessionStorage.setItem(getDealSeenKey(), String(deal.id));
    return;
  }

  const seen = sessionStorage.getItem(getDealSeenKey());
  if (seen === String(deal.id)) return;

  sessionStorage.setItem(getDealSeenKey(), String(deal.id));

  const ok = await waitForTags(deal.order);
  if (!ok) return;

  await runDealAnimation(deal.order);
}

/* =========================
   ★ 山札/場札クリック（ホスト操作）
   ========================= */
async function onDeckClick(e){
  e.preventDefault(); e.stopPropagation();
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  const snap = await get(gameRef);
  const g = snap.val() || { started:false, deck:[], boardCodes:[], boardFaceUpCount:0 };
  if (!g.started) return;

  const deck = Array.isArray(g.deck) ? [...g.deck] : [];
  const boardCodes = Array.isArray(g.boardCodes) ? [...g.boardCodes] : [];
  const faceUpCount = Number(g.boardFaceUpCount || 0);

  if (boardCodes.length === 0){
    if (deck.length < 3) return;
    const drawn = deck.splice(0, 3);
    await update(gameRef, { deck, boardCodes: drawn, boardFaceUpCount: 0 });
    return;
  }

  const allFaceUp = (faceUpCount >= boardCodes.length);
  if (allFaceUp && boardCodes.length < 5){
    if (deck.length < 1) return;
    const c = deck.shift();
    boardCodes.push(c);
    await update(gameRef, { deck, boardCodes, boardFaceUpCount: boardCodes.length });
  }
}
async function onBoardClick(e){
  e.preventDefault(); e.stopPropagation();
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const slot = e.target.closest('.board-slot');
  if (!slot) return;

  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  const snap = await get(gameRef);
  const g = snap.val() || { started:false, deck:[], boardCodes:[], boardFaceUpCount:0 };
  if (!g.started) return;

  const boardCodes = Array.isArray(g.boardCodes) ? [...g.boardCodes] : [];
  const faceUpCount = Number(g.boardFaceUpCount || 0);

  if (boardCodes.length === 0) return;
  if (faceUpCount >= boardCodes.length) return;

  await update(gameRef, { boardFaceUpCount: Math.min(boardCodes.length, faceUpCount + 1) });
}

/* =========================
   subscribe
   ========================= */
function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  });
}
function subscribeGame(){
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  onValue(gameRef, snap => {
    const v = snap.val();
    const base = { started:false, deck:[], boardCodes:[], boardFaceUpCount:0, deal:null };
    state.game = v ? { ...base, ...v } : base;
    renderCenterBoard();
    maybePlayDealFromGame();
  });
}

/* =========================
   ★ 手札描画
   ========================= */
function renderMyHand(){
  myHandEl.innerHTML = '';
  const myId = state.userId;
  const handData = state.hands[myId];
  const finalCards = (handData && Array.isArray(handData.cards)) ? handData.cards : [];
  const shownCount = getShownCount(myId);

  for (let i=0; i<shownCount; i++){
    const wrap = document.createElement('div');
    wrap.className = 'my-card';
    const code = finalCards[i];
    const cardEl = code ? createCardElement(code) : createBackCardElement();
    wrap.appendChild(cardEl);
    myHandEl.appendChild(wrap);
  }
}

function renderHands(){
  renderMyHand();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
}

/* =========================================================
   ★ 入室
   ========================================================= */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeGame();

  syncSeatUI();
  renderCenterBoard();

  // ★ チップ置き場表示＆生成
  chipTray.classList.remove('hidden');
  buildChipTray();
  setTimeout(setAllChipSizeToTag, 30);
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='リンクコピー';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);

    // サイズ追従
    setAllChipSizeToTag();
  });
}

/* =========================================================
   ★ プレイヤー表示 + 自分タグに mycircle + 右にチップ列（←横に出す）
   ========================================================= */
function renderPlayerCircle(players){
  playerCircle.innerHTML = '';
  if (!players.length) return;

  const center = document.createElement('div');
  center.className = 'center-table';
  center.id = 'centerTable';
  center.innerHTML = `
    <div id="deckStack" class="deck-stack empty" title="山札">
      <div id="deckCount" class="deck-count">52</div>
    </div>
    <div id="boardRow" class="board-row" aria-label="場札">
      <div class="board-slot" data-slot="0"></div>
      <div class="board-slot" data-slot="1"></div>
      <div class="board-slot" data-slot="2"></div>
      <div class="board-slot" data-slot="3"></div>
      <div class="board-slot" data-slot="4"></div>
    </div>
  `;
  playerCircle.appendChild(center);

  const n = players.length;
  const rx = 60;
  const ry = 60;

  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + (rx/100)*100 * Math.cos(angle);
    const y = 50 + (ry/100)*100 * Math.sin(angle);

    // ★ 追加：外枠（絶対配置はここに持たせる）
    const wrap = document.createElement('div');
    wrap.className = 'player-wrap';
    wrap.style.left = `${x}%`;
    wrap.style.top  = `${y}%`;

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.dataset.pid = p.id;

    const nameSpan = document.createElement('span');
    nameSpan.textContent = p.name;
    tag.appendChild(nameSpan);

    if (p.id === state.userId){
      // ★ mycircle（名前タグの周り：そのまま tag 内）
      const myc = document.createElement('div');
      myc.className = 'mycircle';
      tag.appendChild(myc);

      // ★ 右側に追加済みチップ列（←tag ではなく wrap に追加＝横に出る）
      const row = document.createElement('div');
      row.className = 'my-chip-row';
      state.myChips.forEach((c, i2)=>{
        const cw = document.createElement('div');
        cw.className = 'chip-wrap';
        cw.innerHTML = chipSVG(c.type, `my_${i2}`);
        row.appendChild(cw);
      });

      wrap.appendChild(tag);
      wrap.appendChild(row);
    } else {
      // 他プレイヤーのミニカード（そのまま）
      tag.onclick = () => {
        if (p.id === state.userId) return;
        if (!state.roomCode) return;
        if (state.seatedTable !== null) return;

        pendingSeatIndexToSteal = p.seatIndex;
        pendingSeatPlayerIdToSteal = p.id;
        kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
        kickDialog.classList.remove('hidden');
      };

      const count = getShownCount(p.id);
      if (count > 0){
        const miniHand = document.createElement('div');
        miniHand.className = 'mini-hand';

        const spread = 70;
        const base = (count > 1) ? (-spread/2) : 0;

        for (let idx2=0; idx2<count; idx2++){
          const card = document.createElement('div');
          card.className = 'mini-card';
          const angleDeg = (count > 1) ? base + (spread/(count-1))*idx2 : 0;
          card.style.transform = `translate(-50%,0) rotate(${angleDeg}deg)`;
          card.style.zIndex = String(10 + idx2);
          miniHand.appendChild(card);
        }
        tag.appendChild(miniHand);
      }

      wrap.appendChild(tag);
    }

    playerCircle.appendChild(wrap);
  });

  renderCenterBoard();
  maybePlayDealFromGame();

  setAllChipSizeToTag();
}

/* =========================
   ★ 追い出しダイアログ（そのまま）
   ========================= */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   ★ ゲーム開始系（そのまま）
   ========================= */
async function ensureGameExistsIfHost(){
  if (!state.isHost || !state.roomCode) return;
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  const snap = await get(gameRef);
  const cur = snap.val();
  const ok =
    cur &&
    typeof cur.started === 'boolean' &&
    Array.isArray(cur.deck) &&
    (Array.isArray(cur.boardCodes) || Array.isArray(cur.board)) &&
    (typeof cur.boardFaceUpCount === 'number' || typeof cur.boardFaceUpCount === 'undefined');
  if (!ok){
    await set(gameRef, { started:false, deck: [], boardCodes: [], boardFaceUpCount: 0, deal:null });
  }
}
async function startGameDeal(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const seated = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? {
      seatIndex: Number(seatIndex),
      id: t.playerId,
      name: t.playerName || '名無し'
    } : null))
    .filter(Boolean)
    .sort((a,b) => a.seatIndex - b.seatIndex);

  const deck = shuffleInPlace(buildDeck52());

  const boardCodes = [];
  const boardFaceUpCount = 0;

  const hands = {};
  seated.forEach(p => hands[p.id] = { cards: [] });

  for (let round=0; round<2; round++){
    for (const p of seated){
      const c = deck.shift();
      if (c) hands[p.id].cards.push(c);
    }
  }

  const deal = { id: Date.now(), at: Date.now(), order: seated.map(p => p.id) };

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    set(ref(db, `${base}/game`), { started:true, deck, boardCodes, boardFaceUpCount, deal }),
    set(ref(db, `${base}/hands`), hands),
  ]);
}
hostSettingsBtn.addEventListener('click', async () => {
  if (!state.isHost) return;
  await ensureGameExistsIfHost();
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => { startPop.classList.add('hidden'); });
btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await startGameDeal();
  startPop.classList.add('hidden');
});
btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;
  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/game`)),
  ]);
  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();

  state.game = { started:false, deck:[], boardCodes:[], boardFaceUpCount:0, deal:null };
  renderCenterBoard();
});

window.addEventListener('load', () => { renderCenterBoard(); });
</script>

</body>
</html>

